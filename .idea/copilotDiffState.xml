<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/authentication/serializer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/authentication/serializer.py" />
              <option name="originalContent" value="from django.contrib.auth.models import User&#10;from rest_framework import serializers&#10;&#10;&#10;class UserSerializer(serializers.ModelSerializer):&#10;    &quot;&quot;&quot;&#10;    Serializer for User model with password confirmation and profile integration.&#10;    Handles user registration with validation for passwords, email uniqueness, and required fields.&#10;    &quot;&quot;&quot;&#10;    # Write-only password fields for security&#10;    password = serializers.CharField(write_only=True)&#10;    password2 = serializers.CharField(write_only=True)&#10;    profile_id = serializers.SerializerMethodField()&#10;&#10;    class Meta:&#10;        model = User&#10;        # Standard fields (avoids exposing password and other sensitive data)&#10;        fields = ['username', 'email', 'password', 'password2', 'first_name', 'last_name', 'profile_id']&#10;        extra_kwargs = {&#10;            'email': {'required': True},  # Make email field required&#10;        }&#10;&#10;    def get_profile_id(self, obj):&#10;        &quot;&quot;&quot;&#10;        Get the profile ID associated with the user.&#10;        Returns None if no profile exists for the user.&#10;        &quot;&quot;&quot;&#10;        profile = getattr(obj, 'profile', None)&#10;&#10;        return getattr(profile, 'id', None) if profile else None&#10;&#10;    def validate(self, attrs):&#10;        &quot;&quot;&quot;&#10;        Validate user data including password confirmation, email uniqueness, and required fields.&#10;        &quot;&quot;&quot;&#10;        # Check if passwords match&#10;        if attrs['password'] != attrs['password2']:&#10;            raise serializers.ValidationError({'password': 'Passwords do not match'})&#10;&#10;        # Check if email is already registered&#10;        if User.objects.filter(email=attrs['email']).exists():&#10;            raise serializers.ValidationError({'email': 'Email already registered'})&#10;&#10;        # Validate that first name is not empty&#10;        if attrs['first_name'] == '':&#10;            raise serializers.ValidationError({'first_name': 'First Name required'})&#10;&#10;        return attrs&#10;&#10;    def create(self, validated_data):&#10;        &quot;&quot;&quot;&#10;        Create a new user instance with validated data.&#10;        Removes password confirmation field before creating the user.&#10;        &quot;&quot;&quot;&#10;        # Remove password confirmation field as it's not needed for user creation&#10;        validated_data.pop('password2', None)&#10;        # Create user with hashed password&#10;        user = User.objects.create_user(**validated_data)&#10;&#10;        return user&#10;" />
              <option name="updatedContent" value="from django.contrib.auth.models import User&#10;from rest_framework import serializers&#10;&#10;&#10;class UserSerializer(serializers.ModelSerializer):&#10;    &quot;&quot;&quot;&#10;    Serializer for User model with password confirmation and profile integration.&#10;    Handles user registration with validation for passwords, email uniqueness, and required fields.&#10;    &quot;&quot;&quot;&#10;    # Write-only password fields for security&#10;    password = serializers.CharField(write_only=True)&#10;    password2 = serializers.CharField(write_only=True)  # Password confirmation field&#10;    profile_id = serializers.SerializerMethodField()  # Read-only field to get associated profile ID&#10;&#10;    class Meta:&#10;        model = User&#10;        # Standard fields (avoids exposing password and other sensitive data)&#10;        fields = ['username', 'email', 'password', 'password2', 'first_name', 'last_name', 'profile_id']&#10;        extra_kwargs = {&#10;            'email': {'required': True},  # Make email field required&#10;        }&#10;&#10;    def get_profile_id(self, obj):&#10;        &quot;&quot;&quot;&#10;        Get the profile ID associated with the user.&#10;        Returns None if no profile exists for the user.&#10;        &quot;&quot;&quot;&#10;        profile = getattr(obj, 'profile', None)&#10;        return getattr(profile, 'id', None) if profile else None&#10;&#10;    def validate(self, attrs):&#10;        &quot;&quot;&quot;&#10;        Validate user data including password confirmation, email uniqueness, and required fields.&#10;        &quot;&quot;&quot;&#10;        # Check if passwords match&#10;        if attrs['password'] != attrs['password2']:&#10;            raise serializers.ValidationError({'password': 'Passwords do not match'})&#10;&#10;        # Check if email is already registered&#10;        if User.objects.filter(email=attrs['email']).exists():&#10;            raise serializers.ValidationError({'email': 'Email already registered'})&#10;&#10;        # Validate that first name is not empty&#10;        if attrs['first_name'] == '':&#10;            raise serializers.ValidationError({'first_name': 'First Name required'})&#10;&#10;        return attrs&#10;&#10;    def create(self, validated_data):&#10;        &quot;&quot;&quot;&#10;        Create a new user instance with validated data.&#10;        Removes password confirmation field before creating the user.&#10;        &quot;&quot;&quot;&#10;        # Remove password confirmation field as it's not needed for user creation&#10;        validated_data.pop('password2', None)&#10;        # Create user with hashed password&#10;        user = User.objects.create_user(**validated_data)&#10;        return user" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/authentication/views.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/authentication/views.py" />
              <option name="originalContent" value="from django.contrib.auth.models import User&#10;from django.shortcuts import render&#10;from drf_spectacular.utils import extend_schema&#10;from rest_framework import generics, status&#10;from rest_framework.permissions import IsAuthenticated, IsAuthenticatedOrReadOnly, AllowAny&#10;from rest_framework.response import Response&#10;&#10;from rest_framework_simplejwt.views import (&#10;    TokenObtainPairView as SimpleJWTTokenObtainPairView,&#10;    TokenRefreshView as SimpleJWTTokenRefreshView,&#10;    TokenVerifyView as SimpleJWTTokenVerifyView,&#10;)&#10;&#10;from authentication.serializer import UserSerializer&#10;from profiles.models import Profile&#10;&#10;&#10;@extend_schema(tags=['User'])&#10;class UsersListAPIView(generics.ListCreateAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for listing all users and creating new user accounts.&#10;    - GET: Returns list of all users (public access)&#10;    - POST: Creates new user with associated profile (public access for registration)&#10;    &quot;&quot;&quot;&#10;    queryset = User.objects.all()&#10;    serializer_class = UserSerializer&#10;    permission_classes = [AllowAny]  # Allow anonymous access for user registration&#10;&#10;    def create(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Create a new user account with automatic profile creation.&#10;        Returns user data with profile ID on successful registration.&#10;        &quot;&quot;&quot;&#10;        serializer = self.get_serializer(data=request.data)&#10;&#10;        if serializer.is_valid():&#10;            # Create user instance&#10;            user = serializer.save()&#10;            # Automatically create associated profile for the new user&#10;            Profile.objects.create(user=user)&#10;&#10;            # Return user data with profile information&#10;            return Response({&#10;                &quot;id&quot;: user.id,&#10;                &quot;username&quot;: user.username,&#10;                &quot;first_name&quot;: user.first_name,&#10;                &quot;last_name&quot;: user.last_name,&#10;                &quot;email&quot;: user.email,&#10;                &quot;is_active&quot;: True,&#10;                &quot;date_joined&quot;: user.date_joined,&#10;                &quot;profile_id&quot;: user.profile.id,&#10;            }, status=status.HTTP_201_CREATED)&#10;        else:&#10;            # Return validation errors&#10;            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;&#10;@extend_schema(tags=['User'])&#10;class UserAPIView(generics.RetrieveUpdateDestroyAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for individual user operations (retrieve, update, delete).&#10;    Requires authentication - users can only access their own data.&#10;    &quot;&quot;&quot;&#10;    queryset = User.objects.all()&#10;    serializer_class = UserSerializer&#10;    permission_classes = [IsAuthenticated]  # Require authentication for all operations&#10;&#10;    def perform_destroy(self, instance):&#10;        &quot;&quot;&quot;&#10;        Delete user account and associated profile.&#10;        Ensures cascade deletion of related profile data.&#10;        &quot;&quot;&quot;&#10;        # Delete associated profile if it exists&#10;        if hasattr(instance, 'profile'):&#10;            instance.profile.delete()&#10;&#10;        # Delete the user instance&#10;        instance.delete()&#10;&#10;&#10;# -----------------------------------------------Views of JWT token ----------------------------------------------------&#10;&#10;@extend_schema(tags=[&quot;JWT Auth&quot;])&#10;class TokenObtainPairView(SimpleJWTTokenObtainPairView):&#10;    &quot;&quot;&quot;&#10;    JWT token obtain view for user authentication.&#10;    Returns access and refresh tokens for valid credentials.&#10;    &quot;&quot;&quot;&#10;    pass&#10;&#10;&#10;@extend_schema(tags=[&quot;JWT Auth&quot;])&#10;class TokenRefreshView(SimpleJWTTokenRefreshView):&#10;    &quot;&quot;&quot;&#10;    JWT token refresh view for obtaining new access tokens.&#10;    Uses refresh token to generate new access token.&#10;    &quot;&quot;&quot;&#10;    pass&#10;&#10;&#10;@extend_schema(tags=[&quot;JWT Auth&quot;])&#10;class TokenVerifyView(SimpleJWTTokenVerifyView):&#10;    &quot;&quot;&quot;&#10;    JWT token verification view to validate token authenticity.&#10;    Checks if provided token is valid and not expired.&#10;    &quot;&quot;&quot;&#10;    pass&#10;" />
              <option name="updatedContent" value="from django.contrib.auth.models import User&#10;from django.shortcuts import render&#10;from drf_spectacular.utils import extend_schema&#10;from rest_framework import generics, status&#10;from rest_framework.permissions import IsAuthenticated, IsAuthenticatedOrReadOnly, AllowAny&#10;from rest_framework.response import Response&#10;&#10;from rest_framework_simplejwt.views import (&#10;    TokenObtainPairView as SimpleJWTTokenObtainPairView,&#10;    TokenRefreshView as SimpleJWTTokenRefreshView,&#10;    TokenVerifyView as SimpleJWTTokenVerifyView,&#10;)&#10;&#10;from authentication.serializer import UserSerializer&#10;from profiles.models import Profile&#10;&#10;&#10;@extend_schema(tags=['User'])&#10;class UsersListAPIView(generics.ListCreateAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for listing all users and creating new user accounts.&#10;    - GET: Returns list of all users (public access)&#10;    - POST: Creates new user with associated profile (public access for registration)&#10;    &quot;&quot;&quot;&#10;    queryset = User.objects.all()&#10;    serializer_class = UserSerializer&#10;    permission_classes = [AllowAny]  # Allow anonymous access for user registration&#10;&#10;    def create(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Create a new user account with automatic profile creation.&#10;        Returns user data with profile ID on successful registration.&#10;        &quot;&quot;&quot;&#10;        serializer = self.get_serializer(data=request.data)&#10;&#10;        if serializer.is_valid():&#10;            # Create user instance&#10;            user = serializer.save()&#10;            # Automatically create associated profile for the new user&#10;            Profile.objects.create(user=user)&#10;&#10;            # Return user data with profile information&#10;            return Response({&#10;                &quot;id&quot;: user.id,&#10;                &quot;username&quot;: user.username,&#10;                &quot;first_name&quot;: user.first_name,&#10;                &quot;last_name&quot;: user.last_name,&#10;                &quot;email&quot;: user.email,&#10;                &quot;is_active&quot;: True,&#10;                &quot;date_joined&quot;: user.date_joined,&#10;                &quot;profile_id&quot;: user.profile.id,&#10;            }, status=status.HTTP_201_CREATED)&#10;        else:&#10;            # Return validation errors&#10;            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;&#10;@extend_schema(tags=['User'])&#10;class UserAPIView(generics.RetrieveUpdateDestroyAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for individual user operations (retrieve, update, delete).&#10;    Requires authentication - users can only access their own data.&#10;    &quot;&quot;&quot;&#10;    queryset = User.objects.all()&#10;    serializer_class = UserSerializer&#10;    permission_classes = [IsAuthenticated]  # Require authentication for all operations&#10;&#10;    def perform_destroy(self, instance):&#10;        &quot;&quot;&quot;&#10;        Delete user account and associated profile.&#10;        Ensures cascade deletion of related profile data.&#10;        &quot;&quot;&quot;&#10;        # Delete associated profile if it exists&#10;        if hasattr(instance, 'profile'):&#10;            instance.profile.delete()&#10;&#10;        # Delete the user instance&#10;        instance.delete()&#10;&#10;&#10;# -----------------------------------------------Views of JWT token ----------------------------------------------------&#10;&#10;@extend_schema(tags=[&quot;JWT Auth&quot;])&#10;class TokenObtainPairView(SimpleJWTTokenObtainPairView):&#10;    &quot;&quot;&quot;&#10;    JWT token obtain view for user authentication.&#10;    Returns access and refresh tokens for valid credentials.&#10;    &quot;&quot;&quot;&#10;    pass&#10;&#10;&#10;@extend_schema(tags=[&quot;JWT Auth&quot;])&#10;class TokenRefreshView(SimpleJWTTokenRefreshView):&#10;    &quot;&quot;&quot;&#10;    JWT token refresh view for obtaining new access tokens.&#10;    Uses refresh token to generate new access token.&#10;    &quot;&quot;&quot;&#10;    pass&#10;&#10;&#10;@extend_schema(tags=[&quot;JWT Auth&quot;])&#10;class TokenVerifyView(SimpleJWTTokenVerifyView):&#10;    &quot;&quot;&quot;&#10;    JWT token verification view to validate token authenticity.&#10;    Checks if provided token is valid and not expired.&#10;    &quot;&quot;&quot;&#10;    pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/groups/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/groups/models.py" />
              <option name="originalContent" value="import secrets&#10;&#10;from django.contrib.auth.models import User&#10;from django.db import models&#10;&#10;&#10;def invate_code_generator():&#10;    &quot;&quot;&quot;&#10;    Generate a unique 6-character URL-safe invite code for groups.&#10;    Used for group invitation functionality.&#10;    &quot;&quot;&quot;&#10;    return secrets.token_urlsafe(6)&#10;&#10;&#10;class Group(models.Model):&#10;    name = models.CharField(max_length=255)&#10;    description = models.TextField(blank=True)&#10;    invite_code = models.CharField(max_length=8, unique=True, editable=False, default=invate_code_generator)&#10;    created_at = models.DateTimeField(auto_now_add=True, editable=False)&#10;    created_by = models.ForeignKey(User, editable=False, on_delete=models.PROTECT, related_name='group_created_by')&#10;    owner = models.ForeignKey(User, on_delete=models.PROTECT, related_name='group_owner', blank=True)&#10;&#10;    def __str__(self):&#10;        return self.name&#10;&#10;    def save(self, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Override save method to automatically add the creator as an admin member&#10;        when a new group is created.&#10;        &quot;&quot;&quot;&#10;        if not self.pk:  # New group creation&#10;            super().save(*args, **kwargs)&#10;            # Automatically add creator as admin member&#10;            GroupMembers.objects.create(member=self.created_by, joined_at=self.created_at, is_admin=True, group=self)&#10;        else:&#10;            super().save(*args, **kwargs)&#10;&#10;&#10;class GroupMembers(models.Model):&#10;    member = models.ForeignKey(User, on_delete=models.CASCADE, editable=False)&#10;    group = models.ForeignKey(Group, on_delete=models.CASCADE, editable=False)&#10;    joined_at = models.DateTimeField(auto_now_add=True, editable=False)&#10;    is_admin = models.BooleanField(default=False)&#10;&#10;    class Meta:&#10;        unique_together = (('member', 'group'),)  # Ensure one membership per user per group&#10;&#10;    def __str__(self):&#10;        return f'Member: {self.member}'&#10;" />
              <option name="updatedContent" value="import secrets&#10;&#10;from django.contrib.auth.models import User&#10;from django.db import models&#10;&#10;&#10;def invate_code_generator():&#10;    &quot;&quot;&quot;&#10;    Generate a unique 6-character URL-safe invite code for groups.&#10;    Used for group invitation functionality.&#10;    &quot;&quot;&quot;&#10;    return secrets.token_urlsafe(6)&#10;&#10;&#10;class Group(models.Model):&#10;    name = models.CharField(max_length=255)&#10;    description = models.TextField(blank=True)&#10;    invite_code = models.CharField(max_length=8, unique=True, editable=False, default=invate_code_generator)&#10;    created_at = models.DateTimeField(auto_now_add=True, editable=False)&#10;    created_by = models.ForeignKey(User, editable=False, on_delete=models.PROTECT, related_name='group_created_by')&#10;    owner = models.ForeignKey(User, on_delete=models.PROTECT, related_name='group_owner', blank=True)&#10;&#10;    def __str__(self):&#10;        return self.name&#10;&#10;    def save(self, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Override save method to automatically add the creator as an admin member&#10;        when a new group is created.&#10;        &quot;&quot;&quot;&#10;        if not self.pk:  # New group creation&#10;            super().save(*args, **kwargs)&#10;            # Automatically add creator as admin member&#10;            GroupMembers.objects.create(member=self.created_by, joined_at=self.created_at, is_admin=True, group=self)&#10;        else:&#10;            super().save(*args, **kwargs)&#10;&#10;&#10;class GroupMembers(models.Model):&#10;    member = models.ForeignKey(User, on_delete=models.CASCADE, editable=False)&#10;    group = models.ForeignKey(Group, on_delete=models.CASCADE, editable=False)&#10;    joined_at = models.DateTimeField(auto_now_add=True, editable=False)&#10;    is_admin = models.BooleanField(default=False)&#10;&#10;    class Meta:&#10;        unique_together = (('member', 'group'),)  # Ensure one membership per user per group&#10;&#10;    def __str__(self):&#10;        return f'Member: {self.member}'" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/groups/serializer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/groups/serializer.py" />
              <option name="originalContent" value="from rest_framework import serializers&#10;&#10;from groups.models import Group, GroupMembers&#10;&#10;&#10;class GroupSerializer(serializers.ModelSerializer):&#10;    class Meta:&#10;        model = Group&#10;        fields = '__all__'&#10;&#10;&#10;class GroupMemberSerializer(serializers.ModelSerializer):&#10;    class Meta:&#10;        model = GroupMembers&#10;        fields = ['member', 'joined_at', 'is_admin']&#10;        read_only_fields = ['member', 'joined_at']&#10;&#10;    def validate(self, attrs):&#10;        &quot;&quot;&quot;&#10;        Custom validation to check that read-only fields are not provided.&#10;        &quot;&quot;&quot;&#10;        if 'joined_at' in self.initial_data:&#10;            raise serializers.ValidationError({&#10;                &quot;joined_at&quot;: &quot;This field is read-only and cannot be modified.&quot;&#10;            })&#10;&#10;        return attrs&#10;" />
              <option name="updatedContent" value="from rest_framework import serializers&#10;&#10;from groups.models import Group, GroupMembers&#10;&#10;&#10;class GroupSerializer(serializers.ModelSerializer):&#10;    &quot;&quot;&quot;&#10;    Serializer for Group model.&#10;    Handles serialization/deserialization of group data for API endpoints.&#10;    &quot;&quot;&quot;&#10;    class Meta:&#10;        model = Group&#10;        fields = '__all__'  # Include all model fields in serialization&#10;&#10;&#10;class GroupMemberSerializer(serializers.ModelSerializer):&#10;    &quot;&quot;&quot;&#10;    Serializer for GroupMembers model.&#10;    Controls which fields can be modified and validates member data.&#10;    Only allows updating admin status, while member and join date are read-only.&#10;    &quot;&quot;&quot;&#10;    class Meta:&#10;        model = GroupMembers&#10;        fields = ['member', 'joined_at', 'is_admin']&#10;        read_only_fields = ['member', 'joined_at']  # Prevent modification of member and join date&#10;&#10;    def validate(self, attrs):&#10;        &quot;&quot;&quot;&#10;        Custom validation to ensure read-only fields are not provided in requests.&#10;        Prevents clients from attempting to modify protected fields.&#10;        &quot;&quot;&quot;&#10;        if 'joined_at' in self.initial_data:&#10;            raise serializers.ValidationError({&#10;                &quot;joined_at&quot;: &quot;This field is read-only and cannot be modified.&quot;&#10;            })&#10;&#10;        return attrs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/groups/views.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/groups/views.py" />
              <option name="originalContent" value="from django.core.exceptions import ObjectDoesNotExist&#10;from drf_spectacular.utils import extend_schema&#10;from rest_framework import status&#10;from rest_framework.exceptions import PermissionDenied&#10;from rest_framework.generics import ListAPIView, RetrieveUpdateDestroyAPIView, ListCreateAPIView&#10;from rest_framework.permissions import IsAuthenticated&#10;from rest_framework.response import Response&#10;from rest_framework.views import APIView&#10;&#10;from groups.models import Group, GroupMembers&#10;from groups.serializer import GroupSerializer, GroupMemberSerializer&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupsAPIView(ListCreateAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for listing all groups and creating new groups.&#10;    - GET: Returns list of all groups&#10;    - POST: Creates new group with authenticated user as owner and admin&#10;    &quot;&quot;&quot;&#10;    queryset = Group.objects.all()&#10;    serializer_class = GroupSerializer&#10;    permission_classes = [IsAuthenticated]&#10;&#10;    def perform_create(self, serializer):&#10;        &quot;&quot;&quot;&#10;        Create a new group with the authenticated user as both creator and owner.&#10;        Automatically grants admin privileges to the creator.&#10;        &quot;&quot;&quot;&#10;        serializer.save(created_by=self.request.user, owner=self.request.user)&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupAPIView(RetrieveUpdateDestroyAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for individual group operations (retrieve, update, delete).&#10;    Only group owners can delete groups.&#10;    &quot;&quot;&quot;&#10;    queryset = Group.objects.all()&#10;    serializer_class = GroupSerializer&#10;    permission_classes = [IsAuthenticated]&#10;&#10;    def destroy(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Delete a group. Only the group owner has permission to delete.&#10;        Ensures proper authorization before deletion.&#10;        &quot;&quot;&quot;&#10;        group = self.get_object()&#10;&#10;        # Check if current user is the group owner&#10;        if request.user != group.owner:&#10;            raise PermissionDenied(&quot;Only the group owner can delete it&quot;)&#10;&#10;        return super().destroy(request, *args, **kwargs)&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupMembersAPIView(ListAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for listing all members of a specific group.&#10;    Read-only endpoint that returns group membership information.&#10;    &quot;&quot;&quot;&#10;    serializer_class = GroupMemberSerializer&#10;    permission_classes = [IsAuthenticated]&#10;    http_method_names = ['get']  # Only allow GET requests&#10;&#10;    def get_queryset(self):&#10;        &quot;&quot;&quot;&#10;        Return all members for the specified group.&#10;        Filters members by group ID from URL parameters.&#10;        &quot;&quot;&quot;&#10;        return GroupMembers.objects.filter(group_id=self.kwargs['group_id'])&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupMemberAPIView(RetrieveUpdateDestroyAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for individual group member operations.&#10;    Handles member admin status updates and member removal with proper permissions.&#10;    &quot;&quot;&quot;&#10;    serializer_class = GroupMemberSerializer&#10;    permission_classes = [IsAuthenticated]&#10;    lookup_field = 'member_id'&#10;&#10;    def get_queryset(self):&#10;        &quot;&quot;&quot;&#10;        Return specific member in a specific group.&#10;        Filters by both group ID and member ID from URL parameters.&#10;        &quot;&quot;&quot;&#10;        return GroupMembers.objects.filter(group_id=self.kwargs['group_id'], member_id=self.kwargs['member_id'])&#10;&#10;    def update(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Update group member information.&#10;        Only allows updating admin status and only by group owner.&#10;        &quot;&quot;&quot;&#10;        group = Group.objects.get(pk=self.kwargs['group_id'])&#10;        group_member = self.get_object()&#10;&#10;        # Ensure only admin status can be updated&#10;        if set(request.data.keys()) - {'is_admin'}:&#10;            return Response(&#10;                {&quot;error&quot;: &quot;Only is_admin field can be updated from group owner&quot;},&#10;                status=status.HTTP_400_BAD_REQUEST&#10;            )&#10;        &#10;        # Check if current user is the group owner&#10;        if group.owner != request.user:&#10;            raise PermissionDenied(&quot;Only the group owner can update admin members&quot;)&#10;&#10;        return super().update(request, *args, **kwargs)&#10;&#10;    def delete(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Remove a member from the group.&#10;        Implements permission hierarchy: admins can remove regular members,&#10;        only owner can remove admin members.&#10;        &quot;&quot;&quot;&#10;        # Get current user's membership status&#10;        member = GroupMembers.objects.filter(member_id=request.user.id).first()&#10;        group = Group.objects.get(pk=self.kwargs['group_id'])&#10;        member_removed = self.get_object()&#10;&#10;        if member:&#10;            # Check if user has admin privileges&#10;            if not member.is_admin:&#10;                raise PermissionDenied(&quot;Only admin group can delete another members&quot;)&#10;&#10;            # Only group owner can remove admin members&#10;            if member_removed.is_admin and member.member != group.owner:&#10;                raise PermissionDenied(&quot;Only group owner can delete admin members&quot;)&#10;        else:&#10;            return Response({&quot;detail&quot;: &quot;User not a member of this groups&quot;}, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;        try:&#10;            # Remove group from member's profile&#10;            member_removed.member.profile.groups.remove(group)&#10;        except ObjectDoesNotExist:&#10;            pass  # Profile doesn't exist, continue with member removal&#10;        except Exception as e:&#10;            return Response({&quot;detail&quot;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;        return super().delete(request, *args, **kwargs)&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class JoinGroupAPIView(APIView):&#10;    &quot;&quot;&quot;&#10;    API view for joining groups using invite codes.&#10;    Allows users to join groups by providing the group's unique invite code.&#10;    &quot;&quot;&quot;&#10;    permission_classes = [IsAuthenticated]&#10;&#10;    def post(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Join a group using an invite code.&#10;        Creates membership record and adds group to user's profile.&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Find group by invite code&#10;            group = Group.objects.get(invite_code=kwargs['invite_code'])&#10;        except Group.DoesNotExist:&#10;            return Response({&quot;detail&quot;: &quot;Group does not exist&quot;}, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;        # Check if user is already a member&#10;        if GroupMembers.objects.filter(group_id=group.id, member_id=request.user.id).exists():&#10;            return Response({&quot;detail&quot;: &quot;User already joined this group&quot;}, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;        try:&#10;            # Create membership record&#10;            GroupMembers.objects.create(group_id=group.id, member_id=request.user.id)&#10;        except Exception as e:&#10;            return Response({&quot;detail&quot;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;        # Add group to user's profile&#10;        request.user.profile.groups.add(group)&#10;&#10;        return Response({&quot;detail&quot;: &quot;User joined this group&quot;}, status=status.HTTP_200_OK)&#10;" />
              <option name="updatedContent" value="from django.core.exceptions import ObjectDoesNotExist&#10;from drf_spectacular.utils import extend_schema&#10;from rest_framework import status&#10;from rest_framework.exceptions import PermissionDenied&#10;from rest_framework.generics import ListAPIView, RetrieveUpdateDestroyAPIView, ListCreateAPIView&#10;from rest_framework.permissions import IsAuthenticated&#10;from rest_framework.response import Response&#10;from rest_framework.views import APIView&#10;&#10;from groups.models import Group, GroupMembers&#10;from groups.serializer import GroupSerializer, GroupMemberSerializer&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupsAPIView(ListCreateAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for listing all groups and creating new groups.&#10;    - GET: Returns list of all groups&#10;    - POST: Creates new group with authenticated user as owner and admin&#10;    &quot;&quot;&quot;&#10;    queryset = Group.objects.all()&#10;    serializer_class = GroupSerializer&#10;    permission_classes = [IsAuthenticated]&#10;&#10;    def perform_create(self, serializer):&#10;        &quot;&quot;&quot;&#10;        Create a new group with the authenticated user as both creator and owner.&#10;        Automatically grants admin privileges to the creator.&#10;        &quot;&quot;&quot;&#10;        serializer.save(created_by=self.request.user, owner=self.request.user)&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupAPIView(RetrieveUpdateDestroyAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for individual group operations (retrieve, update, delete).&#10;    Only group owners can delete groups.&#10;    &quot;&quot;&quot;&#10;    queryset = Group.objects.all()&#10;    serializer_class = GroupSerializer&#10;    permission_classes = [IsAuthenticated]&#10;&#10;    def destroy(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Delete a group. Only the group owner has permission to delete.&#10;        Ensures proper authorization before deletion.&#10;        &quot;&quot;&quot;&#10;        group = self.get_object()&#10;&#10;        # Check if current user is the group owner&#10;        if request.user != group.owner:&#10;            raise PermissionDenied(&quot;Only the group owner can delete it&quot;)&#10;&#10;        return super().destroy(request, *args, **kwargs)&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupMembersAPIView(ListAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for listing all members of a specific group.&#10;    Read-only endpoint that returns group membership information.&#10;    &quot;&quot;&quot;&#10;    serializer_class = GroupMemberSerializer&#10;    permission_classes = [IsAuthenticated]&#10;    http_method_names = ['get']  # Only allow GET requests&#10;&#10;    def get_queryset(self):&#10;        &quot;&quot;&quot;&#10;        Return all members for the specified group.&#10;        Filters members by group ID from URL parameters.&#10;        &quot;&quot;&quot;&#10;        return GroupMembers.objects.filter(group_id=self.kwargs['group_id'])&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class GroupMemberAPIView(RetrieveUpdateDestroyAPIView):&#10;    &quot;&quot;&quot;&#10;    API view for individual group member operations.&#10;    Handles member admin status updates and member removal with proper permissions.&#10;    &quot;&quot;&quot;&#10;    serializer_class = GroupMemberSerializer&#10;    permission_classes = [IsAuthenticated]&#10;    lookup_field = 'member_id'&#10;&#10;    def get_queryset(self):&#10;        &quot;&quot;&quot;&#10;        Return specific member in a specific group.&#10;        Filters by both group ID and member ID from URL parameters.&#10;        &quot;&quot;&quot;&#10;        return GroupMembers.objects.filter(group_id=self.kwargs['group_id'], member_id=self.kwargs['member_id'])&#10;&#10;    def update(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Update group member information.&#10;        Only allows updating admin status and only by group owner.&#10;        &quot;&quot;&quot;&#10;        group = Group.objects.get(pk=self.kwargs['group_id'])&#10;        group_member = self.get_object()&#10;&#10;        # Ensure only admin status can be updated&#10;        if set(request.data.keys()) - {'is_admin'}:&#10;            return Response(&#10;                {&quot;error&quot;: &quot;Only is_admin field can be updated from group owner&quot;},&#10;                status=status.HTTP_400_BAD_REQUEST&#10;            )&#10;        &#10;        # Check if current user is the group owner&#10;        if group.owner != request.user:&#10;            raise PermissionDenied(&quot;Only the group owner can update admin members&quot;)&#10;&#10;        return super().update(request, *args, **kwargs)&#10;&#10;    def delete(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Remove a member from the group.&#10;        Implements permission hierarchy: admins can remove regular members,&#10;        only owner can remove admin members.&#10;        &quot;&quot;&quot;&#10;        # Get current user's membership status&#10;        member = GroupMembers.objects.filter(member_id=request.user.id).first()&#10;        group = Group.objects.get(pk=self.kwargs['group_id'])&#10;        member_removed = self.get_object()&#10;&#10;        if member:&#10;            # Check if user has admin privileges&#10;            if not member.is_admin:&#10;                raise PermissionDenied(&quot;Only admin group can delete another members&quot;)&#10;&#10;            # Only group owner can remove admin members&#10;            if member_removed.is_admin and member.member != group.owner:&#10;                raise PermissionDenied(&quot;Only group owner can delete admin members&quot;)&#10;        else:&#10;            return Response({&quot;detail&quot;: &quot;User not a member of this groups&quot;}, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;        try:&#10;            # Remove group from member's profile&#10;            member_removed.member.profile.groups.remove(group)&#10;        except ObjectDoesNotExist:&#10;            pass  # Profile doesn't exist, continue with member removal&#10;        except Exception as e:&#10;            return Response({&quot;detail&quot;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;        return super().delete(request, *args, **kwargs)&#10;&#10;&#10;@extend_schema(tags=['Groups'])&#10;class JoinGroupAPIView(APIView):&#10;    &quot;&quot;&quot;&#10;    API view for joining groups using invite codes.&#10;    Allows users to join groups by providing the group's unique invite code.&#10;    &quot;&quot;&quot;&#10;    permission_classes = [IsAuthenticated]&#10;&#10;    def post(self, request, *args, **kwargs):&#10;        &quot;&quot;&quot;&#10;        Join a group using an invite code.&#10;        Creates membership record and adds group to user's profile.&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Find group by invite code&#10;            group = Group.objects.get(invite_code=kwargs['invite_code'])&#10;        except Group.DoesNotExist:&#10;            return Response({&quot;detail&quot;: &quot;Group does not exist&quot;}, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;        # Check if user is already a member&#10;        if GroupMembers.objects.filter(group_id=group.id, member_id=request.user.id).exists():&#10;            return Response({&quot;detail&quot;: &quot;User already joined this group&quot;}, status=status.HTTP_400_BAD_REQUEST)&#10;&#10;        try:&#10;            # Create membership record&#10;            GroupMembers.objects.create(group_id=group.id, member_id=request.user.id)&#10;        except Exception as e:&#10;            return Response({&quot;detail&quot;: str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;        # Add group to user's profile&#10;        request.user.profile.groups.add(group)&#10;&#10;        return Response({&quot;detail&quot;: &quot;User joined this group&quot;}, status=status.HTTP_200_OK)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/workouts/serializer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/workouts/serializer.py" />
              <option name="originalContent" value="from django.core.validators import FileExtensionValidator&#10;from rest_framework import serializers&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan&#10;&#10;&#10;class WorkoutCheckinProofSerializer(serializers.ModelSerializer):&#10;    class Meta:&#10;        model = WorkoutCheckinProof&#10;        fields = ['id', 'file']&#10;        read_only_fields = ['id']&#10;&#10;&#10;class WorkoutCheckinSerializer(serializers.ModelSerializer):&#10;    proof_files = serializers.ListField(&#10;        child=serializers.FileField(&#10;            validators=[FileExtensionValidator(&#10;                allowed_extensions=['jpg', 'jpeg', 'png', 'mp4']&#10;            )]&#10;        ),&#10;        write_only=True,&#10;        required=False&#10;    )&#10;    proofs = WorkoutCheckinProofSerializer(many=True, read_only=True)&#10;    current_streak = serializers.SerializerMethodField(read_only=True)&#10;    longest_streak = serializers.SerializerMethodField(read_only=True)&#10;&#10;    class Meta:&#10;        model = WorkoutCheckin&#10;        fields = [&#10;            'id', 'user', 'comments', 'workout_date',&#10;            'duration', 'validation_status', 'base_points',&#10;            'multiplier', 'proof_files', 'proofs', 'current_streak',&#10;            'longest_streak'&#10;        ]&#10;        read_only_fields = ('user', 'base_points', 'multiplier', 'validation_status')&#10;&#10;    def get_current_streak(self, obj):&#10;        try:&#10;            return obj.user.workout_streak.current_streak&#10;        except:&#10;            return 0&#10;&#10;    def get_longest_streak(self, obj):&#10;        try:&#10;            return obj.user.workout_streak.longest_streak&#10;        except:&#10;            return 0&#10;&#10;    def create(self, validated_data):&#10;        files = validated_data.pop('proof_files', [])&#10;        checkin = WorkoutCheckin.objects.create(**validated_data)&#10;&#10;        for f in files:&#10;            WorkoutCheckinProof.objects.create(checkin=checkin, file=f)&#10;&#10;        return checkin&#10;&#10;    def update(self, instance, validated_data):&#10;        if validated_data.keys() - {'comments'}:&#10;            raise serializers.ValidationError('Only comments can be updated.')&#10;&#10;        validated_data = {key: value for key, value in validated_data.items() if key == 'comments'}&#10;&#10;        return super().update(instance, validated_data)&#10;&#10;&#10;class WorkoutPlanSerializer(serializers.ModelSerializer):&#10;    class Meta:&#10;        model = WorkoutPlan&#10;        fields = '__all__'&#10;        read_only_fields = ['id']&#10;&#10;    def validate_pdf_file(self, value):&#10;        if not value.name.endswith('.pdf'):&#10;            raise serializers.ValidationError('The file must be a PDF.')&#10;&#10;        return value&#10;" />
              <option name="updatedContent" value="from django.core.validators import FileExtensionValidator&#10;from rest_framework import serializers&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan&#10;&#10;&#10;class WorkoutCheckinProofSerializer(serializers.ModelSerializer):&#10;    class Meta:&#10;        model = WorkoutCheckinProof&#10;        fields = ['id', 'file']&#10;        read_only_fields = ['id']&#10;&#10;&#10;class WorkoutCheckinSerializer(serializers.ModelSerializer):&#10;    proof_files = serializers.ListField(&#10;        child=serializers.FileField(&#10;            validators=[FileExtensionValidator(&#10;                allowed_extensions=['jpg', 'jpeg', 'png', 'mp4']&#10;            )]&#10;        ),&#10;        write_only=True,&#10;        required=False&#10;    )&#10;    proofs = WorkoutCheckinProofSerializer(many=True, read_only=True)&#10;    current_streak = serializers.SerializerMethodField(read_only=True)&#10;    longest_streak = serializers.SerializerMethodField(read_only=True)&#10;&#10;    class Meta:&#10;        model = WorkoutCheckin&#10;        fields = [&#10;            'id', 'user', 'comments', 'workout_date',&#10;            'duration', 'validation_status', 'base_points',&#10;            'multiplier', 'proof_files', 'proofs', 'current_streak',&#10;            'longest_streak'&#10;        ]&#10;        read_only_fields = ('user', 'base_points', 'multiplier', 'validation_status')&#10;&#10;    def get_current_streak(self, obj):&#10;        try:&#10;            return obj.user.workout_streak.current_streak&#10;        except:&#10;            return 0&#10;&#10;    def get_longest_streak(self, obj):&#10;        try:&#10;            return obj.user.workout_streak.longest_streak&#10;        except:&#10;            return 0&#10;&#10;    def create(self, validated_data):&#10;        files = validated_data.pop('proof_files', [])&#10;        checkin = WorkoutCheckin.objects.create(**validated_data)&#10;&#10;        for f in files:&#10;            WorkoutCheckinProof.objects.create(checkin=checkin, file=f)&#10;&#10;        return checkin&#10;&#10;    def update(self, instance, validated_data):&#10;        if validated_data.keys() - {'comments'}:&#10;            raise serializers.ValidationError('Only comments can be updated.')&#10;&#10;        validated_data = {key: value for key, value in validated_data.items() if key == 'comments'}&#10;&#10;        return super().update(instance, validated_data)&#10;&#10;&#10;class WorkoutPlanSerializer(serializers.ModelSerializer):&#10;    class Meta:&#10;        model = WorkoutPlan&#10;        fields = '__all__'&#10;        read_only_fields = ['id']&#10;&#10;    def validate_pdf_file(self, value):&#10;        if not value.name.endswith('.pdf'):&#10;            raise serializers.ValidationError('The file must be a PDF.')&#10;&#10;        return value" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/workouts/test/test_models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/workouts/test/test_models.py" />
              <option name="originalContent" value="from datetime import timedelta, datetime&#10;from django.test import TestCase&#10;from django.contrib.auth.models import User&#10;from django.core.exceptions import ValidationError&#10;from django.utils import timezone&#10;from django.core.files.uploadedfile import SimpleUploadedFile&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan, WorkoutStreak&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class WorkoutCheckinModelTest(TestCase):&#10;    def setUp(self):&#10;        &quot;&quot;&quot;Configuração inicial para os testes&quot;&quot;&quot;&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        # Criar profile para o usuário&#10;        self.profile = Profile.objects.create(user=self.user, score=0)&#10;&#10;        # Criar status necessário&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        # Criar workout streak&#10;        self.workout_streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=0,&#10;            longest_streak=0&#10;        )&#10;&#10;    def test_workout_checkin_creation(self):&#10;        &quot;&quot;&quot;Testa criação básica de um check-in&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            location='Academia Central',&#10;            comments='Treino de peito e tríceps',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.assertEqual(checkin.user, self.user)&#10;        self.assertEqual(checkin.location, 'Academia Central')&#10;        self.assertEqual(checkin.multiplier, 1.0)&#10;        self.assertIsNotNone(checkin.base_points)&#10;        self.assertEqual(checkin.validation_status, self.status)&#10;&#10;    def test_workout_checkin_str_method(self):&#10;        &quot;&quot;&quot;Testa o método __str__ do WorkoutCheckin&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        expected_str = f'Workout check-in for {self.user}'&#10;        self.assertEqual(str(checkin), expected_str)&#10;&#10;    def test_workout_checkin_future_date_validation(self):&#10;        &quot;&quot;&quot;Testa validação de data futura&quot;&quot;&quot;&#10;        future_date = timezone.now() + timedelta(days=1)&#10;&#10;        with self.assertRaises(ValidationError):&#10;            checkin = WorkoutCheckin(&#10;                user=self.user,&#10;                workout_date=future_date,&#10;                duration=timedelta(minutes=60)&#10;            )&#10;            checkin.full_clean()&#10;&#10;    def test_workout_checkin_negative_duration_validation(self):&#10;        &quot;&quot;&quot;Testa validação de duração negativa&quot;&quot;&quot;&#10;        with self.assertRaises(ValidationError):&#10;            checkin = WorkoutCheckin(&#10;                user=self.user,&#10;                workout_date=timezone.now() - timedelta(hours=1),&#10;                duration=timedelta(minutes=-30)&#10;            )&#10;            checkin.full_clean()&#10;&#10;    def test_workout_checkin_overlapping_validation(self):&#10;        &quot;&quot;&quot;Testa validação de sobreposição de check-ins&quot;&quot;&quot;&#10;        base_time = timezone.now() - timedelta(hours=2)&#10;&#10;        # Criar primeiro check-in&#10;        checkin1 = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=base_time,&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Tentar criar check-in sobreposto&#10;        with self.assertRaises(ValidationError):&#10;            checkin2 = WorkoutCheckin(&#10;                user=self.user,&#10;                workout_date=base_time + timedelta(minutes=30),&#10;                duration=timedelta(minutes=60)&#10;            )&#10;            checkin2.full_clean()&#10;&#10;    def test_multiplier_calculation_levels(self):&#10;        &quot;&quot;&quot;Testa cálculo do multiplicador baseado no streak&quot;&quot;&quot;&#10;        test_cases = [&#10;            (3, 1.0),    # &lt; 5 check-ins&#10;            (7, 1.25),   # 5-9 check-ins&#10;            (15, 1.50),  # 10-19 check-ins&#10;            (25, 1.75),  # 20-39 check-ins&#10;            (50, 2.0),   # 40-79 check-ins&#10;        ]&#10;&#10;        for streak, expected_multiplier in test_cases:&#10;            with self.subTest(streak=streak):&#10;                self.workout_streak.current_streak = streak&#10;                self.workout_streak.save()&#10;&#10;                checkin = WorkoutCheckin.objects.create(&#10;                    user=self.user,&#10;                    workout_date=timezone.now() - timedelta(hours=1),&#10;                    duration=timedelta(minutes=60)&#10;                )&#10;&#10;                self.assertEqual(checkin.multiplier, expected_multiplier)&#10;                checkin.delete()  # Limpar para próximo teste&#10;&#10;    def test_base_points_calculation(self):&#10;        &quot;&quot;&quot;Testa cálculo dos pontos base&quot;&quot;&quot;&#10;        duration_minutes = 60&#10;        multiplier = 1.5&#10;&#10;        self.workout_streak.current_streak = 15  # Para ter multiplier 1.5&#10;        self.workout_streak.save()&#10;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=duration_minutes)&#10;        )&#10;&#10;        expected_points = float(10 * (duration_minutes / 50)) * multiplier&#10;        self.assertEqual(checkin.base_points, expected_points)&#10;&#10;    def test_profile_score_update(self):&#10;        &quot;&quot;&quot;Testa atualização da pontuação do perfil&quot;&quot;&quot;&#10;        initial_score = self.profile.score&#10;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.profile.refresh_from_db()&#10;        self.assertGreater(self.profile.score, initial_score)&#10;        self.assertEqual(self.profile.score, initial_score + checkin.base_points)&#10;&#10;&#10;class WorkoutCheckinProofModelTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;    def test_workout_checkin_proof_creation(self):&#10;        &quot;&quot;&quot;Testa criação de prova de check-in&quot;&quot;&quot;&#10;        # Simular upload de arquivo&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        proof = WorkoutCheckinProof.objects.create(&#10;            checkin=self.checkin,&#10;            file=test_file&#10;        )&#10;&#10;        self.assertEqual(proof.checkin, self.checkin)&#10;        self.assertTrue(proof.file.name.endswith('.jpg'))&#10;&#10;    def test_workout_checkin_proof_relationship(self):&#10;        &quot;&quot;&quot;Testa relacionamento entre checkin e proofs&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        proof = WorkoutCheckinProof.objects.create(&#10;            checkin=self.checkin,&#10;            file=test_file&#10;        )&#10;&#10;        self.assertIn(proof, self.checkin.proofs.all())&#10;&#10;&#10;class WorkoutPlanModelTest(TestCase):&#10;    def setUp(self):&#10;        self.today = timezone.now().date()&#10;&#10;    def test_workout_plan_creation(self):&#10;        &quot;&quot;&quot;Testa criação de plano de treino&quot;&quot;&quot;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano de Hipertrofia',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=SimpleUploadedFile(&quot;plan.pdf&quot;, b&quot;pdf_content&quot;, content_type=&quot;application/pdf&quot;)&#10;        )&#10;&#10;        self.assertEqual(plan.title, 'Plano de Hipertrofia')&#10;        self.assertTrue(plan.is_active)&#10;        self.assertFalse(plan.lifetime)&#10;&#10;    def test_workout_plan_str_method(self):&#10;        &quot;&quot;&quot;Testa método __str__ do WorkoutPlan&quot;&quot;&quot;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano de Definição',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=SimpleUploadedFile(&quot;plan.pdf&quot;, b&quot;pdf_content&quot;, content_type=&quot;application/pdf&quot;)&#10;        )&#10;&#10;        self.assertEqual(str(plan), 'Plano de Definição')&#10;&#10;    def test_workout_plan_lifetime_option(self):&#10;        &quot;&quot;&quot;Testa opção de plano vitalício&quot;&quot;&quot;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano Vitalício',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=365),&#10;            lifetime=True,&#10;            pdf_file=SimpleUploadedFile(&quot;plan.pdf&quot;, b&quot;pdf_content&quot;, content_type=&quot;application/pdf&quot;)&#10;        )&#10;&#10;        self.assertTrue(plan.lifetime)&#10;&#10;&#10;class WorkoutStreakModelTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;    def test_workout_streak_creation(self):&#10;        &quot;&quot;&quot;Testa criação de streak&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.assertEqual(streak.user, self.user)&#10;        self.assertEqual(streak.current_streak, 0)&#10;        self.assertEqual(streak.longest_streak, 0)&#10;        self.assertEqual(streak.frequency, 3)&#10;&#10;    def test_workout_streak_str_method(self):&#10;        &quot;&quot;&quot;Testa método __str__ do WorkoutStreak&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=5,&#10;            longest_streak=10&#10;        )&#10;&#10;        expected_str = f&quot;Streak of {self.user.username}: 5 (Máx: 10)&quot;&#10;        self.assertEqual(str(streak), expected_str)&#10;&#10;    def test_update_streak_first_workout(self):&#10;        &quot;&quot;&quot;Testa atualização de streak no primeiro treino&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(user=self.user)&#10;        workout_date = timezone.now()&#10;&#10;        result = streak.update_streak(workout_date)&#10;&#10;        self.assertEqual(result, 1)&#10;        self.assertEqual(streak.current_streak, 1)&#10;        self.assertEqual(streak.longest_streak, 1)&#10;        self.assertEqual(streak.last_workout_datetime, workout_date)&#10;&#10;    def test_update_streak_consecutive_workouts(self):&#10;        &quot;&quot;&quot;Testa atualização de streak em treinos consecutivos&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(user=self.user)&#10;&#10;        # Primeiro treino&#10;        first_workout = timezone.now() - timedelta(days=2)&#10;        streak.update_streak(first_workout)&#10;&#10;        # Segundo treino&#10;        second_workout = timezone.now() - timedelta(days=1)&#10;        result = streak.update_streak(second_workout)&#10;&#10;        self.assertEqual(result, 2)&#10;        self.assertEqual(streak.current_streak, 2)&#10;        self.assertEqual(streak.longest_streak, 2)&#10;&#10;    def test_streak_reset_after_gap(self):&#10;        &quot;&quot;&quot;Testa reset do streak após intervalo longo&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=5,&#10;            longest_streak=5,&#10;            last_workout_datetime=timezone.now() - timedelta(weeks=2)&#10;        )&#10;&#10;        # Simular treino após gap longo&#10;        new_workout = timezone.now()&#10;        result = streak.update_streak(new_workout)&#10;&#10;        self.assertEqual(result, 1)&#10;        self.assertEqual(streak.current_streak, 1)&#10;        self.assertEqual(streak.longest_streak, 5)  # Mantém o recorde&#10;&#10;    def test_check_streak_ended_current_week(self):&#10;        &quot;&quot;&quot;Testa verificação de streak na semana atual&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            frequency=3,&#10;            last_workout_datetime=timezone.now() - timedelta(days=2)&#10;        )&#10;&#10;        # Criar alguns check-ins na semana atual&#10;        for i in range(2):&#10;            WorkoutCheckin.objects.create(&#10;                user=self.user,&#10;                workout_date=timezone.now() - timedelta(days=i),&#10;                duration=timedelta(minutes=60)&#10;            )&#10;&#10;        # Com 2 check-ins e frequência 3, streak não deve ter terminado ainda&#10;        self.assertFalse(streak.check_streak_ended())&#10;&#10;    def test_check_streak_ended_insufficient_frequency(self):&#10;        &quot;&quot;&quot;Testa verificação de streak com frequência insuficiente&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            frequency=5,&#10;            last_workout_datetime=timezone.now() - timedelta(weeks=1, days=1)&#10;        )&#10;&#10;        # Criar apenas 1 check-in na semana atual (insuficiente para frequência 5)&#10;        WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(days=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Com frequência insuficiente e último treino fora da semana, streak deve ter terminado&#10;        self.assertTrue(streak.check_streak_ended())&#10;" />
              <option name="updatedContent" value="from datetime import timedelta, datetime&#10;from django.test import TestCase&#10;from django.contrib.auth.models import User&#10;from django.core.exceptions import ValidationError&#10;from django.utils import timezone&#10;from django.core.files.uploadedfile import SimpleUploadedFile&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan, WorkoutStreak&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class WorkoutCheckinModelTest(TestCase):&#10;    def setUp(self):&#10;        &quot;&quot;&quot;Configuração inicial para os testes&quot;&quot;&quot;&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        # Criar profile para o usuário&#10;        self.profile = Profile.objects.create(user=self.user, score=0)&#10;&#10;        # Criar status necessário&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        # Criar workout streak&#10;        self.workout_streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=0,&#10;            longest_streak=0&#10;        )&#10;&#10;    def test_workout_checkin_creation(self):&#10;        &quot;&quot;&quot;Testa criação básica de um check-in&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            location='Academia Central',&#10;            comments='Treino de peito e tríceps',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.assertEqual(checkin.user, self.user)&#10;        self.assertEqual(checkin.location, 'Academia Central')&#10;        self.assertEqual(checkin.multiplier, 1.0)&#10;        self.assertIsNotNone(checkin.base_points)&#10;        self.assertEqual(checkin.validation_status, self.status)&#10;&#10;    def test_workout_checkin_str_method(self):&#10;        &quot;&quot;&quot;Testa o método __str__ do WorkoutCheckin&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        expected_str = f'Workout check-in for {self.user}'&#10;        self.assertEqual(str(checkin), expected_str)&#10;&#10;    def test_workout_checkin_future_date_validation(self):&#10;        &quot;&quot;&quot;Testa validação de data futura&quot;&quot;&quot;&#10;        future_date = timezone.now() + timedelta(days=1)&#10;&#10;        with self.assertRaises(ValidationError):&#10;            checkin = WorkoutCheckin(&#10;                user=self.user,&#10;                workout_date=future_date,&#10;                duration=timedelta(minutes=60)&#10;            )&#10;            checkin.full_clean()&#10;&#10;    def test_workout_checkin_negative_duration_validation(self):&#10;        &quot;&quot;&quot;Testa validação de duração negativa&quot;&quot;&quot;&#10;        with self.assertRaises(ValidationError):&#10;            checkin = WorkoutCheckin(&#10;                user=self.user,&#10;                workout_date=timezone.now() - timedelta(hours=1),&#10;                duration=timedelta(minutes=-30)&#10;            )&#10;            checkin.full_clean()&#10;&#10;    def test_workout_checkin_overlapping_validation(self):&#10;        &quot;&quot;&quot;Testa validação de sobreposição de check-ins&quot;&quot;&quot;&#10;        base_time = timezone.now() - timedelta(hours=2)&#10;&#10;        # Criar primeiro check-in&#10;        checkin1 = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=base_time,&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Tentar criar check-in sobreposto&#10;        with self.assertRaises(ValidationError):&#10;            checkin2 = WorkoutCheckin(&#10;                user=self.user,&#10;                workout_date=base_time + timedelta(minutes=30),&#10;                duration=timedelta(minutes=60)&#10;            )&#10;            checkin2.full_clean()&#10;&#10;    def test_multiplier_calculation_levels(self):&#10;        &quot;&quot;&quot;Testa cálculo do multiplicador baseado no streak&quot;&quot;&quot;&#10;        test_cases = [&#10;            (3, 1.0),    # &lt; 5 check-ins&#10;            (7, 1.25),   # 5-9 check-ins&#10;            (15, 1.50),  # 10-19 check-ins&#10;            (25, 1.75),  # 20-39 check-ins&#10;            (50, 2.0),   # 40-79 check-ins&#10;        ]&#10;&#10;        for streak, expected_multiplier in test_cases:&#10;            with self.subTest(streak=streak):&#10;                self.workout_streak.current_streak = streak&#10;                self.workout_streak.save()&#10;&#10;                checkin = WorkoutCheckin.objects.create(&#10;                    user=self.user,&#10;                    workout_date=timezone.now() - timedelta(hours=1),&#10;                    duration=timedelta(minutes=60)&#10;                )&#10;&#10;                self.assertEqual(checkin.multiplier, expected_multiplier)&#10;                checkin.delete()  # Limpar para próximo teste&#10;&#10;    def test_base_points_calculation(self):&#10;        &quot;&quot;&quot;Testa cálculo dos pontos base&quot;&quot;&quot;&#10;        duration_minutes = 60&#10;        multiplier = 1.5&#10;        &#10;        self.workout_streak.current_streak = 15  # Para ter multiplier 1.5&#10;        self.workout_streak.save()&#10;        &#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=duration_minutes)&#10;        )&#10;        &#10;        # O modelo multiplica duration por 60 no save, então temos que ajustar&#10;        # Fórmula: 10 * ((duration_total_seconds / 60) / 50) * multiplier&#10;        # Como duration é multiplicado por 60 no save: duration_minutes * 60 = seconds&#10;        expected_points = float(10 * ((duration_minutes * 60 / 60) / 50)) * multiplier&#10;        self.assertEqual(checkin.base_points, expected_points)&#10;&#10;    def test_profile_score_update(self):&#10;        &quot;&quot;&quot;Testa atualização da pontuação do perfil&quot;&quot;&quot;&#10;        initial_score = self.profile.score&#10;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.profile.refresh_from_db()&#10;        self.assertGreater(self.profile.score, initial_score)&#10;        self.assertEqual(self.profile.score, initial_score + checkin.base_points)&#10;&#10;&#10;class WorkoutCheckinProofModelTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;    def test_workout_checkin_proof_creation(self):&#10;        &quot;&quot;&quot;Testa criação de prova de check-in&quot;&quot;&quot;&#10;        # Simular upload de arquivo&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        proof = WorkoutCheckinProof.objects.create(&#10;            checkin=self.checkin,&#10;            file=test_file&#10;        )&#10;&#10;        self.assertEqual(proof.checkin, self.checkin)&#10;        self.assertTrue(proof.file.name.endswith('.jpg'))&#10;&#10;    def test_workout_checkin_proof_relationship(self):&#10;        &quot;&quot;&quot;Testa relacionamento entre checkin e proofs&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        proof = WorkoutCheckinProof.objects.create(&#10;            checkin=self.checkin,&#10;            file=test_file&#10;        )&#10;&#10;        self.assertIn(proof, self.checkin.proofs.all())&#10;&#10;&#10;class WorkoutPlanModelTest(TestCase):&#10;    def setUp(self):&#10;        self.today = timezone.now().date()&#10;&#10;    def test_workout_plan_creation(self):&#10;        &quot;&quot;&quot;Testa criação de plano de treino&quot;&quot;&quot;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano de Hipertrofia',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=SimpleUploadedFile(&quot;plan.pdf&quot;, b&quot;pdf_content&quot;, content_type=&quot;application/pdf&quot;)&#10;        )&#10;&#10;        self.assertEqual(plan.title, 'Plano de Hipertrofia')&#10;        self.assertTrue(plan.is_active)&#10;        self.assertFalse(plan.lifetime)&#10;&#10;    def test_workout_plan_str_method(self):&#10;        &quot;&quot;&quot;Testa método __str__ do WorkoutPlan&quot;&quot;&quot;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano de Definição',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=SimpleUploadedFile(&quot;plan.pdf&quot;, b&quot;pdf_content&quot;, content_type=&quot;application/pdf&quot;)&#10;        )&#10;&#10;        self.assertEqual(str(plan), 'Plano de Definição')&#10;&#10;    def test_workout_plan_lifetime_option(self):&#10;        &quot;&quot;&quot;Testa opção de plano vitalício&quot;&quot;&quot;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano Vitalício',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=365),&#10;            lifetime=True,&#10;            pdf_file=SimpleUploadedFile(&quot;plan.pdf&quot;, b&quot;pdf_content&quot;, content_type=&quot;application/pdf&quot;)&#10;        )&#10;&#10;        self.assertTrue(plan.lifetime)&#10;&#10;&#10;class WorkoutStreakModelTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;    def test_workout_streak_creation(self):&#10;        &quot;&quot;&quot;Testa criação de streak&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.assertEqual(streak.user, self.user)&#10;        self.assertEqual(streak.current_streak, 0)&#10;        self.assertEqual(streak.longest_streak, 0)&#10;        self.assertEqual(streak.frequency, 3)&#10;&#10;    def test_workout_streak_str_method(self):&#10;        &quot;&quot;&quot;Testa método __str__ do WorkoutStreak&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=5,&#10;            longest_streak=10&#10;        )&#10;&#10;        expected_str = f&quot;Streak of {self.user.username}: 5 (Máx: 10)&quot;&#10;        self.assertEqual(str(streak), expected_str)&#10;&#10;    def test_update_streak_first_workout(self):&#10;        &quot;&quot;&quot;Testa atualização de streak no primeiro treino&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(user=self.user)&#10;        workout_date = timezone.now()&#10;&#10;        result = streak.update_streak(workout_date)&#10;&#10;        self.assertEqual(result, 1)&#10;        self.assertEqual(streak.current_streak, 1)&#10;        self.assertEqual(streak.longest_streak, 1)&#10;        self.assertEqual(streak.last_workout_datetime, workout_date)&#10;&#10;    def test_update_streak_consecutive_workouts(self):&#10;        &quot;&quot;&quot;Testa atualização de streak em treinos consecutivos&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(user=self.user)&#10;&#10;        # Primeiro treino&#10;        first_workout = timezone.now() - timedelta(days=2)&#10;        streak.update_streak(first_workout)&#10;&#10;        # Segundo treino&#10;        second_workout = timezone.now() - timedelta(days=1)&#10;        result = streak.update_streak(second_workout)&#10;&#10;        self.assertEqual(result, 2)&#10;        self.assertEqual(streak.current_streak, 2)&#10;        self.assertEqual(streak.longest_streak, 2)&#10;&#10;    def test_streak_reset_after_gap(self):&#10;        &quot;&quot;&quot;Testa reset do streak após intervalo longo&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=5,&#10;            longest_streak=5,&#10;            last_workout_datetime=timezone.now() - timedelta(weeks=2)&#10;        )&#10;&#10;        # Simular treino após gap longo&#10;        new_workout = timezone.now()&#10;        result = streak.update_streak(new_workout)&#10;&#10;        self.assertEqual(result, 1)&#10;        self.assertEqual(streak.current_streak, 1)&#10;        self.assertEqual(streak.longest_streak, 5)  # Mantém o recorde&#10;&#10;    def test_check_streak_ended_current_week(self):&#10;        &quot;&quot;&quot;Testa verificação de streak na semana atual&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            frequency=3,&#10;            last_workout_datetime=timezone.now() - timedelta(days=2)&#10;        )&#10;&#10;        # Criar alguns check-ins na semana atual&#10;        for i in range(2):&#10;            WorkoutCheckin.objects.create(&#10;                user=self.user,&#10;                workout_date=timezone.now() - timedelta(days=i),&#10;                duration=timedelta(minutes=60)&#10;            )&#10;&#10;        # Com 2 check-ins e frequência 3, streak não deve ter terminado ainda&#10;        self.assertFalse(streak.check_streak_ended())&#10;&#10;    def test_check_streak_ended_insufficient_frequency(self):&#10;        &quot;&quot;&quot;Testa verificação de streak com frequência insuficiente&quot;&quot;&quot;&#10;        streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            frequency=5,&#10;            last_workout_datetime=timezone.now() - timedelta(weeks=1, days=1)&#10;        )&#10;&#10;        # Criar apenas 1 check-in na semana atual (insuficiente para frequência 5)&#10;        WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(days=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Com frequência insuficiente e último treino fora da semana, streak deve ter terminado&#10;        self.assertTrue(streak.check_streak_ended())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/workouts/test/test_serializers.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/workouts/test/test_serializers.py" />
              <option name="originalContent" value="from datetime import timedelta&#10;from django.test import TestCase&#10;from django.contrib.auth.models import User&#10;from django.core.files.uploadedfile import SimpleUploadedFile&#10;from django.utils import timezone&#10;from rest_framework.test import APITestCase&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan, WorkoutStreak&#10;from workouts.serializer import WorkoutCheckinSerializer, WorkoutCheckinProofSerializer, WorkoutPlanSerializer&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class WorkoutCheckinProofSerializerTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;    def test_proof_serializer_fields(self):&#10;        &quot;&quot;&quot;Testa campos do serializer de prova&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        proof = WorkoutCheckinProof.objects.create(&#10;            checkin=self.checkin,&#10;            file=test_file&#10;        )&#10;&#10;        serializer = WorkoutCheckinProofSerializer(proof)&#10;        data = serializer.data&#10;&#10;        self.assertIn('id', data)&#10;        self.assertIn('file', data)&#10;        self.assertEqual(len(data), 2)&#10;&#10;    def test_proof_serializer_creation(self):&#10;        &quot;&quot;&quot;Testa criação através do serializer&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        data = {&#10;            'file': test_file&#10;        }&#10;&#10;        serializer = WorkoutCheckinProofSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        proof = serializer.save(checkin=self.checkin)&#10;        self.assertEqual(proof.checkin, self.checkin)&#10;&#10;&#10;class WorkoutCheckinSerializerTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        self.workout_streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=5,&#10;            longest_streak=10&#10;        )&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;    def test_checkin_serializer_fields(self):&#10;        &quot;&quot;&quot;Testa campos do serializer de check-in&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            location='Academia Central',&#10;            comments='Treino intenso',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        data = serializer.data&#10;&#10;        expected_fields = [&#10;            'id', 'user', 'comments', 'workout_date',&#10;            'duration', 'validation_status', 'base_points',&#10;            'multiplier', 'proofs', 'current_streak', 'longest_streak'&#10;        ]&#10;&#10;        for field in expected_fields:&#10;            self.assertIn(field, data)&#10;&#10;    def test_checkin_serializer_read_only_fields(self):&#10;        &quot;&quot;&quot;Testa campos somente leitura&quot;&quot;&quot;&#10;        data = {&#10;            'user': self.user.id,&#10;            'comments': 'Teste',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=60),&#10;            'base_points': 999,  # Campo read-only&#10;            'multiplier': 999,   # Campo read-only&#10;            'validation_status': 999  # Campo read-only&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        # Os campos read-only não devem estar nos validated_data&#10;        self.assertNotIn('base_points', serializer.validated_data)&#10;        self.assertNotIn('multiplier', serializer.validated_data)&#10;        self.assertNotIn('validation_status', serializer.validated_data)&#10;&#10;    def test_checkin_serializer_with_proof_files(self):&#10;        &quot;&quot;&quot;Testa criação de check-in com arquivos de prova&quot;&quot;&quot;&#10;        test_file1 = SimpleUploadedFile(&#10;            &quot;test1.jpg&quot;,&#10;            b&quot;file_content1&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;        test_file2 = SimpleUploadedFile(&#10;            &quot;test2.png&quot;,&#10;            b&quot;file_content2&quot;,&#10;            content_type=&quot;image/png&quot;&#10;        )&#10;&#10;        data = {&#10;            'comments': 'Treino com provas',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=45),&#10;            'proof_files': [test_file1, test_file2]&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        checkin = serializer.save(user=self.user)&#10;        self.assertEqual(checkin.proofs.count(), 2)&#10;&#10;    def test_checkin_serializer_invalid_file_extension(self):&#10;        &quot;&quot;&quot;Testa validação de extensão de arquivo inválida&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test.txt&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;text/plain&quot;&#10;        )&#10;&#10;        data = {&#10;            'comments': 'Teste com arquivo inválido',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=45),&#10;            'proof_files': [test_file]&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(data=data)&#10;        self.assertFalse(serializer.is_valid())&#10;&#10;    def test_get_current_streak_method(self):&#10;        &quot;&quot;&quot;Testa método get_current_streak&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        self.assertEqual(serializer.get_current_streak(checkin), 5)&#10;&#10;    def test_get_longest_streak_method(self):&#10;        &quot;&quot;&quot;Testa método get_longest_streak&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        self.assertEqual(serializer.get_longest_streak(checkin), 10)&#10;&#10;    def test_get_streak_methods_without_streak(self):&#10;        &quot;&quot;&quot;Testa métodos de streak quando não existe WorkoutStreak&quot;&quot;&quot;&#10;        # Criar usuário sem streak&#10;        user_no_streak = User.objects.create_user(&#10;            username='nostreak',&#10;            email='nostreak@example.com',&#10;            password='testpass123'&#10;        )&#10;        Profile.objects.create(user=user_no_streak, score=0)&#10;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=user_no_streak,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        self.assertEqual(serializer.get_current_streak(checkin), 0)&#10;        self.assertEqual(serializer.get_longest_streak(checkin), 0)&#10;&#10;    def test_update_serializer_only_comments(self):&#10;        &quot;&quot;&quot;Testa que apenas comentários podem ser atualizados&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            comments='Comentário original',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Tentar atualizar apenas comentários - deve funcionar&#10;        data = {'comments': 'Comentário atualizado'}&#10;        serializer = WorkoutCheckinSerializer(checkin, data=data, partial=True)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        updated_checkin = serializer.save()&#10;        self.assertEqual(updated_checkin.comments, 'Comentário atualizado')&#10;&#10;    def test_update_serializer_other_fields_forbidden(self):&#10;        &quot;&quot;&quot;Testa que outros campos não podem ser atualizados&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            comments='Comentário original',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Tentar atualizar outros campos - deve falhar&#10;        data = {&#10;            'comments': 'Comentário atualizado',&#10;            'duration': timedelta(minutes=90)&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin, data=data, partial=True)&#10;        self.assertFalse(serializer.is_valid())&#10;        self.assertIn('Only comments can be updated.', str(serializer.errors))&#10;&#10;&#10;class WorkoutPlanSerializerTest(TestCase):&#10;    def setUp(self):&#10;        self.today = timezone.now().date()&#10;&#10;    def test_plan_serializer_fields(self):&#10;        &quot;&quot;&quot;Testa campos do serializer de plano&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano de Teste',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=test_pdf&#10;        )&#10;&#10;        serializer = WorkoutPlanSerializer(plan)&#10;        data = serializer.data&#10;&#10;        expected_fields = [&#10;            'id', 'title', 'is_active', 'pdf_file',&#10;            'start_plan', 'end_plan', 'lifetime'&#10;        ]&#10;&#10;        for field in expected_fields:&#10;            self.assertIn(field, data)&#10;&#10;    def test_plan_serializer_creation(self):&#10;        &quot;&quot;&quot;Testa criação através do serializer&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        data = {&#10;            'title': 'Novo Plano',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=60),&#10;            'pdf_file': test_pdf,&#10;            'lifetime': True&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        plan = serializer.save()&#10;        self.assertEqual(plan.title, 'Novo Plano')&#10;        self.assertTrue(plan.lifetime)&#10;&#10;    def test_plan_serializer_pdf_validation(self):&#10;        &quot;&quot;&quot;Testa validação de arquivo PDF&quot;&quot;&quot;&#10;        # Arquivo não-PDF&#10;        test_file = SimpleUploadedFile(&#10;            &quot;notpdf.txt&quot;,&#10;            b&quot;not_pdf_content&quot;,&#10;            content_type=&quot;text/plain&quot;&#10;        )&#10;&#10;        data = {&#10;            'title': 'Plano com arquivo inválido',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=30),&#10;            'pdf_file': test_file&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertFalse(serializer.is_valid())&#10;        self.assertIn('pdf_file', serializer.errors)&#10;&#10;    def test_plan_serializer_valid_pdf(self):&#10;        &quot;&quot;&quot;Testa validação de arquivo PDF válido&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;valid_plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        data = {&#10;            'title': 'Plano com PDF válido',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=30),&#10;            'pdf_file': test_pdf&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;    def test_plan_serializer_read_only_id(self):&#10;        &quot;&quot;&quot;Testa que ID é campo somente leitura&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        data = {&#10;            'id': 999,  # Campo read-only&#10;            'title': 'Plano Teste',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=30),&#10;            'pdf_file': test_pdf&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        # ID não deve estar nos validated_data&#10;        self.assertNotIn('id', serializer.validated_data)&#10;&#10;    def test_plan_serializer_update(self):&#10;        &quot;&quot;&quot;Testa atualização através do serializer&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano Original',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=test_pdf&#10;        )&#10;&#10;        data = {&#10;            'title': 'Plano Atualizado',&#10;            'is_active': False&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(plan, data=data, partial=True)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        updated_plan = serializer.save()&#10;        self.assertEqual(updated_plan.title, 'Plano Atualizado')&#10;        self.assertFalse(updated_plan.is_active)&#10;" />
              <option name="updatedContent" value="from datetime import timedelta&#10;from django.test import TestCase&#10;from django.contrib.auth.models import User&#10;from django.core.files.uploadedfile import SimpleUploadedFile&#10;from django.utils import timezone&#10;from rest_framework.test import APITestCase&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan, WorkoutStreak&#10;from workouts.serializer import WorkoutCheckinSerializer, WorkoutCheckinProofSerializer, WorkoutPlanSerializer&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class WorkoutCheckinProofSerializerTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;    def test_proof_serializer_fields(self):&#10;        &quot;&quot;&quot;Testa campos do serializer de prova&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        proof = WorkoutCheckinProof.objects.create(&#10;            checkin=self.checkin,&#10;            file=test_file&#10;        )&#10;&#10;        serializer = WorkoutCheckinProofSerializer(proof)&#10;        data = serializer.data&#10;&#10;        self.assertIn('id', data)&#10;        self.assertIn('file', data)&#10;        self.assertEqual(len(data), 2)&#10;&#10;    def test_proof_serializer_creation(self):&#10;        &quot;&quot;&quot;Testa criação através do serializer&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        data = {&#10;            'file': test_file&#10;        }&#10;&#10;        serializer = WorkoutCheckinProofSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        proof = serializer.save(checkin=self.checkin)&#10;        self.assertEqual(proof.checkin, self.checkin)&#10;&#10;&#10;class WorkoutCheckinSerializerTest(TestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        self.workout_streak = WorkoutStreak.objects.create(&#10;            user=self.user,&#10;            current_streak=5,&#10;            longest_streak=10&#10;        )&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;    def test_checkin_serializer_fields(self):&#10;        &quot;&quot;&quot;Testa campos do serializer de check-in&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            location='Academia Central',&#10;            comments='Treino intenso',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        data = serializer.data&#10;&#10;        expected_fields = [&#10;            'id', 'user', 'comments', 'workout_date',&#10;            'duration', 'validation_status', 'base_points',&#10;            'multiplier', 'proofs', 'current_streak', 'longest_streak'&#10;        ]&#10;&#10;        for field in expected_fields:&#10;            self.assertIn(field, data)&#10;&#10;    def test_checkin_serializer_read_only_fields(self):&#10;        &quot;&quot;&quot;Testa campos somente leitura&quot;&quot;&quot;&#10;        data = {&#10;            'user': self.user.id,&#10;            'comments': 'Teste',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=60),&#10;            'base_points': 999,  # Campo read-only&#10;            'multiplier': 999,   # Campo read-only&#10;            'validation_status': 999  # Campo read-only&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        # Os campos read-only não devem estar nos validated_data&#10;        self.assertNotIn('base_points', serializer.validated_data)&#10;        self.assertNotIn('multiplier', serializer.validated_data)&#10;        self.assertNotIn('validation_status', serializer.validated_data)&#10;&#10;    def test_checkin_serializer_with_proof_files(self):&#10;        &quot;&quot;&quot;Testa criação de check-in com arquivos de prova&quot;&quot;&quot;&#10;        test_file1 = SimpleUploadedFile(&#10;            &quot;test1.jpg&quot;,&#10;            b&quot;file_content1&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;        test_file2 = SimpleUploadedFile(&#10;            &quot;test2.png&quot;,&#10;            b&quot;file_content2&quot;,&#10;            content_type=&quot;image/png&quot;&#10;        )&#10;&#10;        data = {&#10;            'comments': 'Treino com provas',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=45),&#10;            'proof_files': [test_file1, test_file2]&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        checkin = serializer.save(user=self.user)&#10;        self.assertEqual(checkin.proofs.count(), 2)&#10;&#10;    def test_checkin_serializer_invalid_file_extension(self):&#10;        &quot;&quot;&quot;Testa validação de extensão de arquivo inválida&quot;&quot;&quot;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test.txt&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;text/plain&quot;&#10;        )&#10;&#10;        data = {&#10;            'comments': 'Teste com arquivo inválido',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=45),&#10;            'proof_files': [test_file]&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(data=data)&#10;        self.assertFalse(serializer.is_valid())&#10;&#10;    def test_get_current_streak_method(self):&#10;        &quot;&quot;&quot;Testa método get_current_streak&quot;&quot;&quot;&#10;        # Ajustar o streak atual antes de criar o checkin&#10;        self.workout_streak.current_streak = 5&#10;        self.workout_streak.save()&#10;        &#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        # O streak pode ter sido atualizado durante a criação do checkin&#10;        current_streak = self.user.workout_streak.current_streak&#10;        self.assertEqual(serializer.get_current_streak(checkin), current_streak)&#10;&#10;    def test_get_longest_streak_method(self):&#10;        &quot;&quot;&quot;Testa método get_longest_streak&quot;&quot;&quot;&#10;        # Definir o longest streak antes de criar o checkin&#10;        self.workout_streak.longest_streak = 10&#10;        self.workout_streak.save()&#10;        &#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        # O longest streak pode ter sido atualizado&#10;        longest_streak = self.user.workout_streak.longest_streak&#10;        self.assertEqual(serializer.get_longest_streak(checkin), longest_streak)&#10;&#10;    def test_get_streak_methods_without_streak(self):&#10;        &quot;&quot;&quot;Testa métodos de streak quando não existe WorkoutStreak&quot;&quot;&quot;&#10;        # Criar usuário sem streak&#10;        user_no_streak = User.objects.create_user(&#10;            username='nostreak',&#10;            email='nostreak@example.com',&#10;            password='testpass123'&#10;        )&#10;        Profile.objects.create(user=user_no_streak, score=0)&#10;        &#10;        # Não criar WorkoutStreak para este usuário&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=user_no_streak,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin)&#10;        # Como um WorkoutStreak será criado automaticamente no save, verificamos o valor atual&#10;        self.assertEqual(serializer.get_current_streak(checkin), 1)  # Primeiro check-in&#10;        self.assertEqual(serializer.get_longest_streak(checkin), 1)  # Primeiro check-in&#10;&#10;    def test_update_serializer_only_comments(self):&#10;        &quot;&quot;&quot;Testa que apenas comentários podem ser atualizados&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            comments='Comentário original',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Tentar atualizar apenas comentários - deve funcionar&#10;        data = {'comments': 'Comentário atualizado'}&#10;        serializer = WorkoutCheckinSerializer(checkin, data=data, partial=True)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        updated_checkin = serializer.save()&#10;        self.assertEqual(updated_checkin.comments, 'Comentário atualizado')&#10;&#10;    def test_update_serializer_other_fields_forbidden(self):&#10;        &quot;&quot;&quot;Testa que outros campos não podem ser atualizados&quot;&quot;&quot;&#10;        checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            comments='Comentário original',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        # Tentar atualizar outros campos - deve falhar&#10;        data = {&#10;            'comments': 'Comentário atualizado',&#10;            'duration': timedelta(minutes=90)&#10;        }&#10;&#10;        serializer = WorkoutCheckinSerializer(checkin, data=data, partial=True)&#10;        self.assertFalse(serializer.is_valid())&#10;        self.assertIn('Only comments can be updated.', str(serializer.errors))&#10;&#10;&#10;class WorkoutPlanSerializerTest(TestCase):&#10;    def setUp(self):&#10;        self.today = timezone.now().date()&#10;&#10;    def test_plan_serializer_fields(self):&#10;        &quot;&quot;&quot;Testa campos do serializer de plano&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano de Teste',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=test_pdf&#10;        )&#10;&#10;        serializer = WorkoutPlanSerializer(plan)&#10;        data = serializer.data&#10;&#10;        expected_fields = [&#10;            'id', 'title', 'is_active', 'pdf_file',&#10;            'start_plan', 'end_plan', 'lifetime'&#10;        ]&#10;&#10;        for field in expected_fields:&#10;            self.assertIn(field, data)&#10;&#10;    def test_plan_serializer_creation(self):&#10;        &quot;&quot;&quot;Testa criação através do serializer&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        data = {&#10;            'title': 'Novo Plano',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=60),&#10;            'pdf_file': test_pdf,&#10;            'lifetime': True&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        plan = serializer.save()&#10;        self.assertEqual(plan.title, 'Novo Plano')&#10;        self.assertTrue(plan.lifetime)&#10;&#10;    def test_plan_serializer_pdf_validation(self):&#10;        &quot;&quot;&quot;Testa validação de arquivo PDF&quot;&quot;&quot;&#10;        # Arquivo não-PDF&#10;        test_file = SimpleUploadedFile(&#10;            &quot;notpdf.txt&quot;,&#10;            b&quot;not_pdf_content&quot;,&#10;            content_type=&quot;text/plain&quot;&#10;        )&#10;&#10;        data = {&#10;            'title': 'Plano com arquivo inválido',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=30),&#10;            'pdf_file': test_file&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertFalse(serializer.is_valid())&#10;        self.assertIn('pdf_file', serializer.errors)&#10;&#10;    def test_plan_serializer_valid_pdf(self):&#10;        &quot;&quot;&quot;Testa validação de arquivo PDF válido&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;valid_plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        data = {&#10;            'title': 'Plano com PDF válido',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=30),&#10;            'pdf_file': test_pdf&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;    def test_plan_serializer_read_only_id(self):&#10;        &quot;&quot;&quot;Testa que ID é campo somente leitura&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        data = {&#10;            'id': 999,  # Campo read-only&#10;            'title': 'Plano Teste',&#10;            'start_plan': self.today,&#10;            'end_plan': self.today + timedelta(days=30),&#10;            'pdf_file': test_pdf&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(data=data)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        # ID não deve estar nos validated_data&#10;        self.assertNotIn('id', serializer.validated_data)&#10;&#10;    def test_plan_serializer_update(self):&#10;        &quot;&quot;&quot;Testa atualização através do serializer&quot;&quot;&quot;&#10;        test_pdf = SimpleUploadedFile(&#10;            &quot;plan.pdf&quot;,&#10;            b&quot;pdf_content&quot;,&#10;            content_type=&quot;application/pdf&quot;&#10;        )&#10;&#10;        plan = WorkoutPlan.objects.create(&#10;            title='Plano Original',&#10;            start_plan=self.today,&#10;            end_plan=self.today + timedelta(days=30),&#10;            pdf_file=test_pdf&#10;        )&#10;&#10;        data = {&#10;            'title': 'Plano Atualizado',&#10;            'is_active': False&#10;        }&#10;&#10;        serializer = WorkoutPlanSerializer(plan, data=data, partial=True)&#10;        self.assertTrue(serializer.is_valid())&#10;&#10;        updated_plan = serializer.save()&#10;        self.assertEqual(updated_plan.title, 'Plano Atualizado')&#10;        self.assertFalse(updated_plan.is_active)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/workouts/test/test_urls.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/workouts/test/test_urls.py" />
              <option name="originalContent" value="from django.test import TestCase&#10;from django.urls import reverse, resolve&#10;from django.contrib.auth.models import User&#10;from django.utils import timezone&#10;from datetime import timedelta&#10;&#10;from workouts.views import (&#10;    WorkoutCheckinsAPIView,&#10;    WorkoutCheckinAPIView,&#10;    WorkoutCheckinsByUserAPIView,&#10;    WorkoutPlansAPIView,&#10;    WorkoutPlanAPIView&#10;)&#10;from workouts.models import WorkoutCheckin, WorkoutPlan, WorkoutStreak&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class WorkoutURLsTest(TestCase):&#10;    def setUp(self):&#10;        &quot;&quot;&quot;Configuração inicial para os testes de URLs&quot;&quot;&quot;&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.plan = WorkoutPlan.objects.create(&#10;            title='Plano Teste',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=30)&#10;        )&#10;&#10;    def test_workout_list_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL da lista de workouts resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-list')&#10;        self.assertEqual(url, '/api/v1/workouts/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinsAPIView)&#10;&#10;    def test_workout_detail_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL de detalhes do workout resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-detail', kwargs={'pk': self.checkin.pk})&#10;        self.assertEqual(url, f'/api/v1/workouts/{self.checkin.pk}/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinAPIView)&#10;&#10;    def test_workout_by_user_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL de workouts por usuário resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-by-user', kwargs={'user_id': self.user.id})&#10;        self.assertEqual(url, f'/api/v1/workouts/user/{self.user.id}/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinsByUserAPIView)&#10;&#10;    def test_workout_plans_list_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL da lista de planos resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-plans-list')&#10;        self.assertEqual(url, '/api/v1/workouts/plans/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutPlansAPIView)&#10;&#10;    def test_workout_plan_detail_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL de detalhes do plano resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-plan-detail', kwargs={'pk': self.plan.pk})&#10;        self.assertEqual(url, f'/api/v1/workouts/plans/{self.plan.pk}/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutPlanAPIView)&#10;&#10;    def test_all_url_names_exist(self):&#10;        &quot;&quot;&quot;Testa se todos os nomes de URLs estão definidos&quot;&quot;&quot;&#10;        url_names = [&#10;            'workout-list',&#10;            'workout-detail',&#10;            'workout-by-user',&#10;            'workout-plans-list',&#10;            'workout-plan-detail'&#10;        ]&#10;&#10;        for url_name in url_names:&#10;            with self.subTest(url_name=url_name):&#10;                try:&#10;                    if url_name in ['workout-detail', 'workout-plan-detail']:&#10;                        reverse(url_name, kwargs={'pk': 1})&#10;                    elif url_name == 'workout-by-user':&#10;                        reverse(url_name, kwargs={'user_id': 1})&#10;                    else:&#10;                        reverse(url_name)&#10;                except Exception as e:&#10;                    self.fail(f&quot;URL name '{url_name}' not found: {e}&quot;)&#10;&#10;    def test_url_patterns_coverage(self):&#10;        &quot;&quot;&quot;Testa se todas as views têm URLs correspondentes&quot;&quot;&quot;&#10;        view_classes = [&#10;            WorkoutCheckinsAPIView,&#10;            WorkoutCheckinAPIView,&#10;            WorkoutCheckinsByUserAPIView,&#10;            WorkoutPlansAPIView,&#10;            WorkoutPlanAPIView&#10;        ]&#10;&#10;        # Mapear URLs e verificar se todas as views estão cobertas&#10;        url_patterns = [&#10;            '/workouts/',&#10;            f'/workouts/{self.checkin.pk}/',&#10;            f'/workouts/user/{self.user.id}/',&#10;            '/workouts/plans/',&#10;            f'/workouts/plans/{self.plan.pk}/'&#10;        ]&#10;&#10;        for pattern in url_patterns:&#10;            with self.subTest(pattern=pattern):&#10;                try:&#10;                    resolved = resolve(pattern)&#10;                    self.assertIn(resolved.func.view_class, view_classes)&#10;                except Exception as e:&#10;                    self.fail(f&quot;URL pattern '{pattern}' failed to resolve: {e}&quot;)&#10;&#10;    def test_url_parameters_validation(self):&#10;        &quot;&quot;&quot;Testa validação de parâmetros nas URLs&quot;&quot;&quot;&#10;        # Testa parâmetros numéricos válidos&#10;        valid_ids = [1, 999, self.checkin.pk, self.user.id]&#10;&#10;        for valid_id in valid_ids:&#10;            with self.subTest(id=valid_id):&#10;                # URL de detalhes do workout&#10;                url = reverse('workout-detail', kwargs={'pk': valid_id})&#10;                self.assertTrue(url.endswith(f'{valid_id}/'))&#10;&#10;                # URL de workouts por usuário&#10;                url = reverse('workout-by-user', kwargs={'user_id': valid_id})&#10;                self.assertTrue(url.endswith(f'user/{valid_id}/'))&#10;&#10;                # URL de detalhes do plano&#10;                url = reverse('workout-plan-detail', kwargs={'pk': valid_id})&#10;                self.assertTrue(url.endswith(f'plans/{valid_id}/'))&#10;&#10;    def test_url_namespace_consistency(self):&#10;        &quot;&quot;&quot;Testa consistência de namespace nas URLs&quot;&quot;&quot;&#10;        # Todas as URLs devem começar com '/workouts/'&#10;        base_urls = [&#10;            reverse('workout-list'),&#10;            reverse('workout-detail', kwargs={'pk': 1}),&#10;            reverse('workout-by-user', kwargs={'user_id': 1}),&#10;            reverse('workout-plans-list'),&#10;            reverse('workout-plan-detail', kwargs={'pk': 1})&#10;        ]&#10;&#10;        for url in base_urls:&#10;            with self.subTest(url=url):&#10;                self.assertTrue(url.startswith('/workouts/'))&#10;&#10;    def test_url_trailing_slash_consistency(self):&#10;        &quot;&quot;&quot;Testa consistência de trailing slash nas URLs&quot;&quot;&quot;&#10;        # Todas as URLs devem terminar com '/'&#10;        base_urls = [&#10;            reverse('workout-list'),&#10;            reverse('workout-detail', kwargs={'pk': 1}),&#10;            reverse('workout-by-user', kwargs={'user_id': 1}),&#10;            reverse('workout-plans-list'),&#10;            reverse('workout-plan-detail', kwargs={'pk': 1})&#10;        ]&#10;&#10;        for url in base_urls:&#10;            with self.subTest(url=url):&#10;                self.assertTrue(url.endswith('/'))&#10;&#10;    def test_url_pattern_specificity(self):&#10;        &quot;&quot;&quot;Testa especificidade dos padrões de URL&quot;&quot;&quot;&#10;        # URLs mais específicas não devem ser confundidas com genéricas&#10;&#10;        # '/workouts/plans/' deve resolver para planos, não para detalhes de workout&#10;        plans_url = reverse('workout-plans-list')&#10;        resolved = resolve(plans_url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutPlansAPIView)&#10;&#10;        # '/workouts/user/1/' deve resolver para workouts por usuário&#10;        user_workouts_url = reverse('workout-by-user', kwargs={'user_id': 1})&#10;        resolved = resolve(user_workouts_url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinsByUserAPIView)&#10;&#10;    def test_dynamic_url_parameters(self):&#10;        &quot;&quot;&quot;Testa parâmetros dinâmicos nas URLs&quot;&quot;&quot;&#10;        # Criar diferentes objetos para testar&#10;        user2 = User.objects.create_user(&#10;            username='user2',&#10;            email='user2@example.com',&#10;            password='pass123'&#10;        )&#10;        Profile.objects.create(user=user2, score=0)&#10;        WorkoutStreak.objects.create(user=user2)&#10;&#10;        checkin2 = WorkoutCheckin.objects.create(&#10;            user=user2,&#10;            workout_date=timezone.now() - timedelta(hours=2),&#10;            duration=timedelta(minutes=45)&#10;        )&#10;&#10;        plan2 = WorkoutPlan.objects.create(&#10;            title='Segundo Plano',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=60)&#10;        )&#10;&#10;        # Testar URLs com diferentes IDs&#10;        test_cases = [&#10;            ('workout-detail', {'pk': checkin2.pk}),&#10;            ('workout-by-user', {'user_id': user2.id}),&#10;            ('workout-plan-detail', {'pk': plan2.pk})&#10;        ]&#10;&#10;        for url_name, kwargs in test_cases:&#10;            with self.subTest(url_name=url_name, kwargs=kwargs):&#10;                url = reverse(url_name, kwargs=kwargs)&#10;                resolved = resolve(url)&#10;                self.assertEqual(resolved.kwargs, kwargs)&#10;" />
              <option name="updatedContent" value="from django.test import TestCase&#10;from django.urls import reverse, resolve&#10;from django.contrib.auth.models import User&#10;from django.utils import timezone&#10;from datetime import timedelta&#10;&#10;from workouts.views import (&#10;    WorkoutCheckinsAPIView,&#10;    WorkoutCheckinAPIView,&#10;    WorkoutCheckinsByUserAPIView,&#10;    WorkoutPlansAPIView,&#10;    WorkoutPlanAPIView&#10;)&#10;from workouts.models import WorkoutCheckin, WorkoutPlan, WorkoutStreak&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class WorkoutURLsTest(TestCase):&#10;    def setUp(self):&#10;        &quot;&quot;&quot;Configuração inicial para os testes de URLs&quot;&quot;&quot;&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.plan = WorkoutPlan.objects.create(&#10;            title='Plano Teste',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=30)&#10;        )&#10;&#10;    def test_workout_list_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL da lista de workouts resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-list')&#10;        self.assertEqual(url, '/api/v1/workouts/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinsAPIView)&#10;&#10;    def test_workout_detail_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL de detalhes do workout resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-detail', kwargs={'pk': self.checkin.pk})&#10;        self.assertEqual(url, f'/api/v1/workouts/{self.checkin.pk}/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinAPIView)&#10;&#10;    def test_workout_by_user_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL de workouts por usuário resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-by-user', kwargs={'user_id': self.user.id})&#10;        self.assertEqual(url, f'/api/v1/workouts/user/{self.user.id}/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinsByUserAPIView)&#10;&#10;    def test_workout_plans_list_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL da lista de planos resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-plans-list')&#10;        self.assertEqual(url, '/api/v1/workouts/plans/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutPlansAPIView)&#10;&#10;    def test_workout_plan_detail_url_resolves(self):&#10;        &quot;&quot;&quot;Testa se a URL de detalhes do plano resolve corretamente&quot;&quot;&quot;&#10;        url = reverse('workout-plan-detail', kwargs={'pk': self.plan.pk})&#10;        self.assertEqual(url, f'/api/v1/workouts/plans/{self.plan.pk}/')&#10;&#10;        resolved = resolve(url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutPlanAPIView)&#10;&#10;    def test_all_url_names_exist(self):&#10;        &quot;&quot;&quot;Testa se todos os nomes de URLs estão definidos&quot;&quot;&quot;&#10;        url_names = [&#10;            'workout-list',&#10;            'workout-detail',&#10;            'workout-by-user',&#10;            'workout-plans-list',&#10;            'workout-plan-detail'&#10;        ]&#10;&#10;        for url_name in url_names:&#10;            with self.subTest(url_name=url_name):&#10;                try:&#10;                    if url_name in ['workout-detail', 'workout-plan-detail']:&#10;                        reverse(url_name, kwargs={'pk': 1})&#10;                    elif url_name == 'workout-by-user':&#10;                        reverse(url_name, kwargs={'user_id': 1})&#10;                    else:&#10;                        reverse(url_name)&#10;                except Exception as e:&#10;                    self.fail(f&quot;URL name '{url_name}' not found: {e}&quot;)&#10;&#10;    def test_url_patterns_coverage(self):&#10;        &quot;&quot;&quot;Testa se todas as views têm URLs correspondentes&quot;&quot;&quot;&#10;        view_classes = [&#10;            WorkoutCheckinsAPIView,&#10;            WorkoutCheckinAPIView,&#10;            WorkoutCheckinsByUserAPIView,&#10;            WorkoutPlansAPIView,&#10;            WorkoutPlanAPIView&#10;        ]&#10;&#10;        # Mapear URLs e verificar se todas as views estão cobertas&#10;        url_patterns = [&#10;            f'/api/v1/workouts/',&#10;            f'/api/v1/workouts/{self.checkin.pk}/',&#10;            f'/api/v1/workouts/user/{self.user.id}/',&#10;            f'/api/v1/workouts/plans/',&#10;            f'/api/v1/workouts/plans/{self.plan.pk}/'&#10;        ]&#10;&#10;        for pattern in url_patterns:&#10;            with self.subTest(pattern=pattern):&#10;                try:&#10;                    resolved = resolve(pattern)&#10;                    self.assertIn(resolved.func.view_class, view_classes)&#10;                except Exception as e:&#10;                    self.fail(f&quot;URL pattern '{pattern}' failed to resolve: {e}&quot;)&#10;&#10;    def test_url_parameters_validation(self):&#10;        &quot;&quot;&quot;Testa validação de parâmetros nas URLs&quot;&quot;&quot;&#10;        # Testa parâmetros numéricos válidos&#10;        valid_ids = [1, 999, self.checkin.pk, self.user.id]&#10;&#10;        for valid_id in valid_ids:&#10;            with self.subTest(id=valid_id):&#10;                # URL de detalhes do workout&#10;                url = reverse('workout-detail', kwargs={'pk': valid_id})&#10;                self.assertTrue(url.endswith(f'{valid_id}/'))&#10;&#10;                # URL de workouts por usuário&#10;                url = reverse('workout-by-user', kwargs={'user_id': valid_id})&#10;                self.assertTrue(url.endswith(f'user/{valid_id}/'))&#10;&#10;                # URL de detalhes do plano&#10;                url = reverse('workout-plan-detail', kwargs={'pk': valid_id})&#10;                self.assertTrue(url.endswith(f'plans/{valid_id}/'))&#10;&#10;    def test_url_namespace_consistency(self):&#10;        &quot;&quot;&quot;Testa consistência de namespace nas URLs&quot;&quot;&quot;&#10;        # Todas as URLs devem começar com '/api/v1/workouts/'&#10;        base_urls = [&#10;            reverse('workout-list'),&#10;            reverse('workout-detail', kwargs={'pk': 1}),&#10;            reverse('workout-by-user', kwargs={'user_id': 1}),&#10;            reverse('workout-plans-list'),&#10;            reverse('workout-plan-detail', kwargs={'pk': 1})&#10;        ]&#10;&#10;        for url in base_urls:&#10;            with self.subTest(url=url):&#10;                self.assertTrue(url.startswith('/api/v1/workouts/'))&#10;&#10;    def test_url_trailing_slash_consistency(self):&#10;        &quot;&quot;&quot;Testa consistência de trailing slash nas URLs&quot;&quot;&quot;&#10;        # Todas as URLs devem terminar com '/'&#10;        base_urls = [&#10;            reverse('workout-list'),&#10;            reverse('workout-detail', kwargs={'pk': 1}),&#10;            reverse('workout-by-user', kwargs={'user_id': 1}),&#10;            reverse('workout-plans-list'),&#10;            reverse('workout-plan-detail', kwargs={'pk': 1})&#10;        ]&#10;&#10;        for url in base_urls:&#10;            with self.subTest(url=url):&#10;                self.assertTrue(url.endswith('/'))&#10;&#10;    def test_url_pattern_specificity(self):&#10;        &quot;&quot;&quot;Testa especificidade dos padrões de URL&quot;&quot;&quot;&#10;        # URLs mais específicas não devem ser confundidas com genéricas&#10;&#10;        # '/workouts/plans/' deve resolver para planos, não para detalhes de workout&#10;        plans_url = reverse('workout-plans-list')&#10;        resolved = resolve(plans_url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutPlansAPIView)&#10;&#10;        # '/workouts/user/1/' deve resolver para workouts por usuário&#10;        user_workouts_url = reverse('workout-by-user', kwargs={'user_id': 1})&#10;        resolved = resolve(user_workouts_url)&#10;        self.assertEqual(resolved.func.view_class, WorkoutCheckinsByUserAPIView)&#10;&#10;    def test_dynamic_url_parameters(self):&#10;        &quot;&quot;&quot;Testa parâmetros dinâmicos nas URLs&quot;&quot;&quot;&#10;        # Criar diferentes objetos para testar&#10;        user2 = User.objects.create_user(&#10;            username='user2',&#10;            email='user2@example.com',&#10;            password='pass123'&#10;        )&#10;        Profile.objects.create(user=user2, score=0)&#10;        WorkoutStreak.objects.create(user=user2)&#10;&#10;        checkin2 = WorkoutCheckin.objects.create(&#10;            user=user2,&#10;            workout_date=timezone.now() - timedelta(hours=2),&#10;            duration=timedelta(minutes=45)&#10;        )&#10;&#10;        plan2 = WorkoutPlan.objects.create(&#10;            title='Segundo Plano',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=60)&#10;        )&#10;&#10;        # Testar URLs com diferentes IDs&#10;        test_cases = [&#10;            ('workout-detail', {'pk': checkin2.pk}),&#10;            ('workout-by-user', {'user_id': user2.id}),&#10;            ('workout-plan-detail', {'pk': plan2.pk})&#10;        ]&#10;&#10;        for url_name, kwargs in test_cases:&#10;            with self.subTest(url_name=url_name, kwargs=kwargs):&#10;                url = reverse(url_name, kwargs=kwargs)&#10;                resolved = resolve(url)&#10;                self.assertEqual(resolved.kwargs, kwargs)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/workouts/test/test_views.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/workouts/test/test_views.py" />
              <option name="originalContent" value="from datetime import timedelta&#10;from django.test import TestCase&#10;from django.contrib.auth.models import User&#10;from django.core.files.uploadedfile import SimpleUploadedFile&#10;from django.utils import timezone&#10;from django.urls import reverse&#10;from rest_framework.test import APITestCase, APIClient&#10;from rest_framework import status&#10;from rest_framework.authtoken.models import Token&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan, WorkoutStreak&#10;from workouts.views import IsOwnerOrReadOnly&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class IsOwnerOrReadOnlyPermissionTest(TestCase):&#10;    def setUp(self):&#10;        self.user1 = User.objects.create_user(&#10;            username='user1',&#10;            email='user1@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        self.user2 = User.objects.create_user(&#10;            username='user2',&#10;            email='user2@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user1, score=0)&#10;        Profile.objects.create(user=self.user2, score=0)&#10;        WorkoutStreak.objects.create(user=self.user1)&#10;        WorkoutStreak.objects.create(user=self.user2)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user1,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;    def test_owner_can_modify_object(self):&#10;        &quot;&quot;&quot;Testa que o proprietário pode modificar o objeto&quot;&quot;&quot;&#10;        permission = IsOwnerOrReadOnly()&#10;&#10;        # Simular request de modificação do proprietário&#10;        class MockRequest:&#10;            method = 'PUT'&#10;            user = self.user1&#10;&#10;        request = MockRequest()&#10;        has_permission = permission.has_object_permission(request, None, self.checkin)&#10;        self.assertTrue(has_permission)&#10;&#10;    def test_non_owner_cannot_modify_object(self):&#10;        &quot;&quot;&quot;Testa que não-proprietário não pode modificar o objeto&quot;&quot;&quot;&#10;        permission = IsOwnerOrReadOnly()&#10;&#10;        # Simular request de modificação de não-proprietário&#10;        class MockRequest:&#10;            method = 'PUT'&#10;            user = self.user2&#10;&#10;        request = MockRequest()&#10;        has_permission = permission.has_object_permission(request, None, self.checkin)&#10;        self.assertFalse(has_permission)&#10;&#10;    def test_anyone_can_read_object(self):&#10;        &quot;&quot;&quot;Testa que qualquer um pode ler o objeto&quot;&quot;&quot;&#10;        permission = IsOwnerOrReadOnly()&#10;&#10;        safe_methods = ['GET', 'HEAD', 'OPTIONS']&#10;&#10;        for method in safe_methods:&#10;            with self.subTest(method=method):&#10;                class MockRequest:&#10;                    method = method&#10;                    user = self.user2  # Usuário diferente do proprietário&#10;&#10;                request = MockRequest()&#10;                has_permission = permission.has_object_permission(request, None, self.checkin)&#10;                self.assertTrue(has_permission)&#10;&#10;&#10;class WorkoutCheckinsAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.token = Token.objects.create(user=self.user)&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-list')&#10;&#10;    def test_unauthenticated_access_denied(self):&#10;        &quot;&quot;&quot;Testa que acesso não autenticado é negado&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_authenticated_can_list_workouts(self):&#10;        &quot;&quot;&quot;Testa que usuário autenticado pode listar workouts&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # Criar alguns check-ins&#10;        WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=2),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;        WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=45)&#10;        )&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 2)&#10;&#10;    def test_create_workout_checkin_success(self):&#10;        &quot;&quot;&quot;Testa criação bem-sucedida de check-in&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {&#10;            'location': 'Academia Central',&#10;            'comments': 'Treino de peito',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=60)&#10;        }&#10;&#10;        response = self.client.post(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_201_CREATED)&#10;        self.assertEqual(WorkoutCheckin.objects.count(), 1)&#10;&#10;        checkin = WorkoutCheckin.objects.first()&#10;        self.assertEqual(checkin.user, self.user)&#10;        self.assertEqual(checkin.location, 'Academia Central')&#10;&#10;    def test_create_workout_checkin_with_files(self):&#10;        &quot;&quot;&quot;Testa criação de check-in com arquivos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        data = {&#10;            'comments': 'Treino com prova',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=45),&#10;            'proof_files': [test_file]&#10;        }&#10;&#10;        response = self.client.post(self.url, data, format='multipart')&#10;        self.assertEqual(response.status_code, status.HTTP_201_CREATED)&#10;&#10;        checkin = WorkoutCheckin.objects.first()&#10;        self.assertEqual(checkin.proofs.count(), 1)&#10;&#10;    def test_create_workout_checkin_validation_error(self):&#10;        &quot;&quot;&quot;Testa erro de validação na criação&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # Data futura (deve gerar erro)&#10;        data = {&#10;            'workout_date': timezone.now() + timedelta(days=1),&#10;            'duration': timedelta(minutes=60)&#10;        }&#10;&#10;        response = self.client.post(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)&#10;        self.assertIn('detail', response.data)&#10;&#10;    def test_create_workout_checkin_invalid_data(self):&#10;        &quot;&quot;&quot;Testa criação com dados inválidos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {&#10;            'workout_date': 'invalid_date',&#10;            'duration': 'invalid_duration'&#10;        }&#10;&#10;        response = self.client.post(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)&#10;&#10;&#10;class WorkoutCheckinAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        self.other_user = User.objects.create_user(&#10;            username='otheruser',&#10;            email='other@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        Profile.objects.create(user=self.other_user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;        WorkoutStreak.objects.create(user=self.other_user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            comments='Treino original',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-detail', kwargs={'pk': self.checkin.pk})&#10;&#10;    def test_retrieve_workout_checkin(self):&#10;        &quot;&quot;&quot;Testa recuperação de check-in específico&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(response.data['id'], self.checkin.id)&#10;&#10;    def test_owner_can_update_comments(self):&#10;        &quot;&quot;&quot;Testa que proprietário pode atualizar comentários&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {'comments': 'Comentário atualizado'}&#10;        response = self.client.patch(self.url, data)&#10;&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;&#10;        self.checkin.refresh_from_db()&#10;        self.assertEqual(self.checkin.comments, 'Comentário atualizado')&#10;&#10;    def test_non_owner_cannot_update(self):&#10;        &quot;&quot;&quot;Testa que não-proprietário não pode atualizar&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.other_user)&#10;&#10;        data = {'comments': 'Tentativa de atualização'}&#10;        response = self.client.patch(self.url, data)&#10;&#10;        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)&#10;&#10;    def test_update_other_fields_forbidden(self):&#10;        &quot;&quot;&quot;Testa que outros campos não podem ser atualizados&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {&#10;            'comments': 'Novo comentário',&#10;            'duration': timedelta(minutes=90)&#10;        }&#10;&#10;        response = self.client.patch(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)&#10;&#10;    def test_owner_can_delete(self):&#10;        &quot;&quot;&quot;Testa que proprietário pode deletar&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.delete(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)&#10;        self.assertFalse(WorkoutCheckin.objects.filter(pk=self.checkin.pk).exists())&#10;&#10;    def test_non_owner_cannot_delete(self):&#10;        &quot;&quot;&quot;Testa que não-proprietário não pode deletar&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.other_user)&#10;&#10;        response = self.client.delete(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)&#10;&#10;&#10;class WorkoutCheckinsByUserAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        # Criar check-ins em diferentes datas&#10;        self.checkin1 = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(days=2),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.checkin2 = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(days=1),&#10;            duration=timedelta(minutes=45)&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-by-user', kwargs={'user_id': self.user.id})&#10;&#10;    def test_get_user_workouts_ordered_by_date(self):&#10;        &quot;&quot;&quot;Testa recuperação de workouts do usuário ordenados por data&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 2)&#10;&#10;        # Verificar ordenação (mais recente primeiro)&#10;        dates = [item['workout_date'] for item in response.data]&#10;        self.assertGreater(dates[0], dates[1])&#10;&#10;    def test_only_authenticated_access(self):&#10;        &quot;&quot;&quot;Testa que apenas usuários autenticados podem acessar&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_empty_result_for_user_without_workouts(self):&#10;        &quot;&quot;&quot;Testa resultado vazio para usuário sem workouts&quot;&quot;&quot;&#10;        user_no_workouts = User.objects.create_user(&#10;            username='noworkouts',&#10;            email='no@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        url = reverse('workout-by-user', kwargs={'user_id': user_no_workouts.id})&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 0)&#10;&#10;&#10;class WorkoutPlansAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.plan1 = WorkoutPlan.objects.create(&#10;            title='Plano de Hipertrofia',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=30)&#10;        )&#10;&#10;        self.plan2 = WorkoutPlan.objects.create(&#10;            title='Plano de Definição',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=60),&#10;            is_active=False&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-plans-list')&#10;&#10;    def test_list_all_workout_plans(self):&#10;        &quot;&quot;&quot;Testa listagem de todos os planos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 2)&#10;&#10;    def test_unauthenticated_access_denied(self):&#10;        &quot;&quot;&quot;Testa que acesso não autenticado é negado&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_includes_inactive_plans(self):&#10;        &quot;&quot;&quot;Testa que planos inativos também são incluídos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;&#10;        plan_titles = [plan['title'] for plan in response.data]&#10;        self.assertIn('Plano de Hipertrofia', plan_titles)&#10;        self.assertIn('Plano de Definição', plan_titles)&#10;&#10;&#10;class WorkoutPlanAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.plan = WorkoutPlan.objects.create(&#10;            title='Plano Teste',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=30)&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-plan-detail', kwargs={'pk': self.plan.pk})&#10;&#10;    def test_retrieve_workout_plan(self):&#10;        &quot;&quot;&quot;Testa recuperação de plano específico&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(response.data['id'], self.plan.id)&#10;        self.assertEqual(response.data['title'], 'Plano Teste')&#10;&#10;    def test_update_workout_plan(self):&#10;        &quot;&quot;&quot;Testa atualização de plano&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {'title': 'Plano Atualizado'}&#10;        response = self.client.patch(self.url, data)&#10;&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;&#10;        self.plan.refresh_from_db()&#10;        self.assertEqual(self.plan.title, 'Plano Atualizado')&#10;&#10;    def test_delete_workout_plan(self):&#10;        &quot;&quot;&quot;Testa exclusão de plano&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.delete(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)&#10;        self.assertFalse(WorkoutPlan.objects.filter(pk=self.plan.pk).exists())&#10;&#10;    def test_unauthenticated_access_denied(self):&#10;        &quot;&quot;&quot;Testa que acesso não autenticado é negado&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_nonexistent_plan_returns_404(self):&#10;        &quot;&quot;&quot;Testa que plano inexistente retorna 404&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        url = reverse('workout-plan-detail', kwargs={'pk': 9999})&#10;        response = self.client.get(url)&#10;        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)&#10;&#10;&#10;class WorkoutViewsIntegrationTest(APITestCase):&#10;    &quot;&quot;&quot;Testes de integração para as views de workout&quot;&quot;&quot;&#10;&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.client = APIClient()&#10;&#10;    def test_complete_workout_flow(self):&#10;        &quot;&quot;&quot;Testa fluxo completo de workout&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # 1. Criar check-in&#10;        create_data = {&#10;            'location': 'Academia',&#10;            'comments': 'Treino completo',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=60)&#10;        }&#10;&#10;        create_response = self.client.post(reverse('workout-list'), create_data)&#10;        self.assertEqual(create_response.status_code, status.HTTP_201_CREATED)&#10;&#10;        checkin_id = create_response.data['id']&#10;&#10;        # 2. Recuperar check-in criado&#10;        detail_response = self.client.get(&#10;            reverse('workout-detail', kwargs={'pk': checkin_id})&#10;        )&#10;        self.assertEqual(detail_response.status_code, status.HTTP_200_OK)&#10;&#10;        # 3. Atualizar comentários&#10;        update_data = {'comments': 'Treino atualizado'}&#10;        update_response = self.client.patch(&#10;            reverse('workout-detail', kwargs={'pk': checkin_id}),&#10;            update_data&#10;        )&#10;        self.assertEqual(update_response.status_code, status.HTTP_200_OK)&#10;&#10;        # 4. Verificar em lista de usuário&#10;        user_list_response = self.client.get(&#10;            reverse('workout-by-user', kwargs={'user_id': self.user.id})&#10;        )&#10;        self.assertEqual(user_list_response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(user_list_response.data), 1)&#10;&#10;        # 5. Deletar check-in&#10;        delete_response = self.client.delete(&#10;            reverse('workout-detail', kwargs={'pk': checkin_id})&#10;        )&#10;        self.assertEqual(delete_response.status_code, status.HTTP_204_NO_CONTENT)&#10;&#10;    def test_streak_calculation_through_api(self):&#10;        &quot;&quot;&quot;Testa cálculo de streak através da API&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # Criar múltiplos check-ins para testar streak&#10;        for i in range(3):&#10;            data = {&#10;                'workout_date': timezone.now() - timedelta(days=i),&#10;                'duration': timedelta(minutes=60)&#10;            }&#10;            response = self.client.post(reverse('workout-list'), data)&#10;            self.assertEqual(response.status_code, status.HTTP_201_CREATED)&#10;&#10;        # Verificar streak no último check-in&#10;        last_checkin_response = self.client.get(reverse('workout-list'))&#10;        self.assertEqual(last_checkin_response.status_code, status.HTTP_200_OK)&#10;&#10;        # Pelo menos um check-in deve ter streak &gt; 0&#10;        has_streak = any(&#10;            item['current_streak'] &gt; 0&#10;            for item in last_checkin_response.data&#10;        )&#10;        self.assertTrue(has_streak)&#10;" />
              <option name="updatedContent" value="from datetime import timedelta&#10;from django.test import TestCase&#10;from django.contrib.auth.models import User&#10;from django.core.files.uploadedfile import SimpleUploadedFile&#10;from django.utils import timezone&#10;from django.urls import reverse&#10;from rest_framework.test import APITestCase, APIClient&#10;from rest_framework import status&#10;&#10;from workouts.models import WorkoutCheckin, WorkoutCheckinProof, WorkoutPlan, WorkoutStreak&#10;from workouts.views import IsOwnerOrReadOnly&#10;from status.models import Status&#10;from profiles.models import Profile&#10;&#10;&#10;class IsOwnerOrReadOnlyPermissionTest(TestCase):&#10;    def setUp(self):&#10;        self.user1 = User.objects.create_user(&#10;            username='user1',&#10;            email='user1@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        self.user2 = User.objects.create_user(&#10;            username='user2',&#10;            email='user2@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user1, score=0)&#10;        Profile.objects.create(user=self.user2, score=0)&#10;        WorkoutStreak.objects.create(user=self.user1)&#10;        WorkoutStreak.objects.create(user=self.user2)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user1,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;    def test_owner_can_modify_object(self):&#10;        &quot;&quot;&quot;Testa que o proprietário pode modificar o objeto&quot;&quot;&quot;&#10;        permission = IsOwnerOrReadOnly()&#10;&#10;        # Simular request de modificação do proprietário&#10;        class MockRequest:&#10;            method = 'PUT'&#10;            user = self.user1&#10;&#10;        request = MockRequest()&#10;        has_permission = permission.has_object_permission(request, None, self.checkin)&#10;        self.assertTrue(has_permission)&#10;&#10;    def test_non_owner_cannot_modify_object(self):&#10;        &quot;&quot;&quot;Testa que não-proprietário não pode modificar o objeto&quot;&quot;&quot;&#10;        permission = IsOwnerOrReadOnly()&#10;&#10;        # Simular request de modificação de não-proprietário&#10;        class MockRequest:&#10;            method = 'PUT'&#10;            user = self.user2&#10;&#10;        request = MockRequest()&#10;        has_permission = permission.has_object_permission(request, None, self.checkin)&#10;        self.assertFalse(has_permission)&#10;&#10;    def test_anyone_can_read_object(self):&#10;        &quot;&quot;&quot;Testa que qualquer um pode ler o objeto&quot;&quot;&quot;&#10;        permission = IsOwnerOrReadOnly()&#10;        &#10;        safe_methods = ['GET', 'HEAD', 'OPTIONS']&#10;        &#10;        for method in safe_methods:&#10;            with self.subTest(method=method):&#10;                class MockRequest:&#10;                    def __init__(self, method_name):&#10;                        self.method = method_name&#10;                        self.user = self.user2  # Usuário diferente do proprietário&#10;                &#10;                request = MockRequest(method)&#10;                has_permission = permission.has_object_permission(request, None, self.checkin)&#10;                self.assertTrue(has_permission)&#10;&#10;&#10;class WorkoutCheckinsAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-list')&#10;&#10;    def test_unauthenticated_access_denied(self):&#10;        &quot;&quot;&quot;Testa que acesso não autenticado é negado&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_authenticated_can_list_workouts(self):&#10;        &quot;&quot;&quot;Testa que usuário autenticado pode listar workouts&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # Criar alguns check-ins&#10;        WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=2),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;        WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=45)&#10;        )&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 2)&#10;&#10;    def test_create_workout_checkin_success(self):&#10;        &quot;&quot;&quot;Testa criação bem-sucedida de check-in&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {&#10;            'location': 'Academia Central',&#10;            'comments': 'Treino de peito',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=60)&#10;        }&#10;&#10;        response = self.client.post(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_201_CREATED)&#10;        self.assertEqual(WorkoutCheckin.objects.count(), 1)&#10;&#10;        checkin = WorkoutCheckin.objects.first()&#10;        self.assertEqual(checkin.user, self.user)&#10;        self.assertEqual(checkin.location, 'Academia Central')&#10;&#10;    def test_create_workout_checkin_with_files(self):&#10;        &quot;&quot;&quot;Testa criação de check-in com arquivos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        test_file = SimpleUploadedFile(&#10;            &quot;test_image.jpg&quot;,&#10;            b&quot;file_content&quot;,&#10;            content_type=&quot;image/jpeg&quot;&#10;        )&#10;&#10;        data = {&#10;            'comments': 'Treino com prova',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=45),&#10;            'proof_files': [test_file]&#10;        }&#10;&#10;        response = self.client.post(self.url, data, format='multipart')&#10;        self.assertEqual(response.status_code, status.HTTP_201_CREATED)&#10;&#10;        checkin = WorkoutCheckin.objects.first()&#10;        self.assertEqual(checkin.proofs.count(), 1)&#10;&#10;    def test_create_workout_checkin_validation_error(self):&#10;        &quot;&quot;&quot;Testa erro de validação na criação&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # Data futura (deve gerar erro)&#10;        data = {&#10;            'workout_date': timezone.now() + timedelta(days=1),&#10;            'duration': timedelta(minutes=60)&#10;        }&#10;&#10;        response = self.client.post(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)&#10;        self.assertIn('detail', response.data)&#10;&#10;    def test_create_workout_checkin_invalid_data(self):&#10;        &quot;&quot;&quot;Testa criação com dados inválidos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {&#10;            'workout_date': 'invalid_date',&#10;            'duration': 'invalid_duration'&#10;        }&#10;&#10;        response = self.client.post(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)&#10;&#10;&#10;class WorkoutCheckinAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        self.other_user = User.objects.create_user(&#10;            username='otheruser',&#10;            email='other@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        Profile.objects.create(user=self.other_user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;        WorkoutStreak.objects.create(user=self.other_user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.checkin = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            comments='Treino original',&#10;            workout_date=timezone.now() - timedelta(hours=1),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-detail', kwargs={'pk': self.checkin.pk})&#10;&#10;    def test_retrieve_workout_checkin(self):&#10;        &quot;&quot;&quot;Testa recuperação de check-in específico&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(response.data['id'], self.checkin.id)&#10;&#10;    def test_owner_can_update_comments(self):&#10;        &quot;&quot;&quot;Testa que proprietário pode atualizar comentários&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {'comments': 'Comentário atualizado'}&#10;        response = self.client.patch(self.url, data)&#10;&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;&#10;        self.checkin.refresh_from_db()&#10;        self.assertEqual(self.checkin.comments, 'Comentário atualizado')&#10;&#10;    def test_non_owner_cannot_update(self):&#10;        &quot;&quot;&quot;Testa que não-proprietário não pode atualizar&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.other_user)&#10;&#10;        data = {'comments': 'Tentativa de atualização'}&#10;        response = self.client.patch(self.url, data)&#10;&#10;        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)&#10;&#10;    def test_update_other_fields_forbidden(self):&#10;        &quot;&quot;&quot;Testa que outros campos não podem ser atualizados&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {&#10;            'comments': 'Novo comentário',&#10;            'duration': timedelta(minutes=90)&#10;        }&#10;&#10;        response = self.client.patch(self.url, data)&#10;        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)&#10;&#10;    def test_owner_can_delete(self):&#10;        &quot;&quot;&quot;Testa que proprietário pode deletar&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.delete(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)&#10;        self.assertFalse(WorkoutCheckin.objects.filter(pk=self.checkin.pk).exists())&#10;&#10;    def test_non_owner_cannot_delete(self):&#10;        &quot;&quot;&quot;Testa que não-proprietário não pode deletar&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.other_user)&#10;&#10;        response = self.client.delete(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)&#10;&#10;&#10;class WorkoutCheckinsByUserAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        # Criar check-ins em diferentes datas com intervalos maiores para evitar sobreposição&#10;        self.checkin1 = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(days=2),&#10;            duration=timedelta(minutes=60)&#10;        )&#10;&#10;        self.checkin2 = WorkoutCheckin.objects.create(&#10;            user=self.user,&#10;            workout_date=timezone.now() - timedelta(days=1, hours=12),  # Maior intervalo&#10;            duration=timedelta(minutes=45)&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-by-user', kwargs={'user_id': self.user.id})&#10;&#10;    def test_get_user_workouts_ordered_by_date(self):&#10;        &quot;&quot;&quot;Testa recuperação de workouts do usuário ordenados por data&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 2)&#10;&#10;        # Verificar ordenação (mais recente primeiro)&#10;        dates = [item['workout_date'] for item in response.data]&#10;        self.assertGreater(dates[0], dates[1])&#10;&#10;    def test_only_authenticated_access(self):&#10;        &quot;&quot;&quot;Testa que apenas usuários autenticados podem acessar&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_empty_result_for_user_without_workouts(self):&#10;        &quot;&quot;&quot;Testa resultado vazio para usuário sem workouts&quot;&quot;&quot;&#10;        user_no_workouts = User.objects.create_user(&#10;            username='noworkouts',&#10;            email='no@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        url = reverse('workout-by-user', kwargs={'user_id': user_no_workouts.id})&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 0)&#10;&#10;&#10;class WorkoutPlansAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.plan1 = WorkoutPlan.objects.create(&#10;            title='Plano de Hipertrofia',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=30)&#10;        )&#10;&#10;        self.plan2 = WorkoutPlan.objects.create(&#10;            title='Plano de Definição',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=60),&#10;            is_active=False&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-plans-list')&#10;&#10;    def test_list_all_workout_plans(self):&#10;        &quot;&quot;&quot;Testa listagem de todos os planos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(response.data), 2)&#10;&#10;    def test_unauthenticated_access_denied(self):&#10;        &quot;&quot;&quot;Testa que acesso não autenticado é negado&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_includes_inactive_plans(self):&#10;        &quot;&quot;&quot;Testa que planos inativos também são incluídos&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;&#10;        plan_titles = [plan['title'] for plan in response.data]&#10;        self.assertIn('Plano de Hipertrofia', plan_titles)&#10;        self.assertIn('Plano de Definição', plan_titles)&#10;&#10;&#10;class WorkoutPlanAPIViewTest(APITestCase):&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;&#10;        self.plan = WorkoutPlan.objects.create(&#10;            title='Plano Teste',&#10;            start_plan=timezone.now().date(),&#10;            end_plan=timezone.now().date() + timedelta(days=30)&#10;        )&#10;&#10;        self.client = APIClient()&#10;        self.url = reverse('workout-plan-detail', kwargs={'pk': self.plan.pk})&#10;&#10;    def test_retrieve_workout_plan(self):&#10;        &quot;&quot;&quot;Testa recuperação de plano específico&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(response.data['id'], self.plan.id)&#10;        self.assertEqual(response.data['title'], 'Plano Teste')&#10;&#10;    def test_update_workout_plan(self):&#10;        &quot;&quot;&quot;Testa atualização de plano&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        data = {'title': 'Plano Atualizado'}&#10;        response = self.client.patch(self.url, data)&#10;&#10;        self.assertEqual(response.status_code, status.HTTP_200_OK)&#10;&#10;        self.plan.refresh_from_db()&#10;        self.assertEqual(self.plan.title, 'Plano Atualizado')&#10;&#10;    def test_delete_workout_plan(self):&#10;        &quot;&quot;&quot;Testa exclusão de plano&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        response = self.client.delete(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)&#10;        self.assertFalse(WorkoutPlan.objects.filter(pk=self.plan.pk).exists())&#10;&#10;    def test_unauthenticated_access_denied(self):&#10;        &quot;&quot;&quot;Testa que acesso não autenticado é negado&quot;&quot;&quot;&#10;        response = self.client.get(self.url)&#10;        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)&#10;&#10;    def test_nonexistent_plan_returns_404(self):&#10;        &quot;&quot;&quot;Testa que plano inexistente retorna 404&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        url = reverse('workout-plan-detail', kwargs={'pk': 9999})&#10;        response = self.client.get(url)&#10;        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)&#10;&#10;&#10;class WorkoutViewsIntegrationTest(APITestCase):&#10;    &quot;&quot;&quot;Testes de integração para as views de workout&quot;&quot;&quot;&#10;&#10;    def setUp(self):&#10;        self.user = User.objects.create_user(&#10;            username='testuser',&#10;            email='test@example.com',&#10;            password='testpass123'&#10;        )&#10;&#10;        Profile.objects.create(user=self.user, score=0)&#10;        WorkoutStreak.objects.create(user=self.user)&#10;&#10;        self.status = Status.objects.create(&#10;            name='Published',&#10;            app_name='WORKOUT',&#10;            action='PUBLISHED',&#10;            is_active=True&#10;        )&#10;&#10;        self.client = APIClient()&#10;&#10;    def test_complete_workout_flow(self):&#10;        &quot;&quot;&quot;Testa fluxo completo de workout&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # 1. Criar check-in&#10;        create_data = {&#10;            'location': 'Academia',&#10;            'comments': 'Treino completo',&#10;            'workout_date': timezone.now() - timedelta(hours=1),&#10;            'duration': timedelta(minutes=60)&#10;        }&#10;&#10;        create_response = self.client.post(reverse('workout-list'), create_data)&#10;        self.assertEqual(create_response.status_code, status.HTTP_201_CREATED)&#10;&#10;        checkin_id = create_response.data['id']&#10;&#10;        # 2. Recuperar check-in criado&#10;        detail_response = self.client.get(&#10;            reverse('workout-detail', kwargs={'pk': checkin_id})&#10;        )&#10;        self.assertEqual(detail_response.status_code, status.HTTP_200_OK)&#10;&#10;        # 3. Atualizar comentários&#10;        update_data = {'comments': 'Treino atualizado'}&#10;        update_response = self.client.patch(&#10;            reverse('workout-detail', kwargs={'pk': checkin_id}),&#10;            update_data&#10;        )&#10;        self.assertEqual(update_response.status_code, status.HTTP_200_OK)&#10;&#10;        # 4. Verificar em lista de usuário&#10;        user_list_response = self.client.get(&#10;            reverse('workout-by-user', kwargs={'user_id': self.user.id})&#10;        )&#10;        self.assertEqual(user_list_response.status_code, status.HTTP_200_OK)&#10;        self.assertEqual(len(user_list_response.data), 1)&#10;&#10;        # 5. Deletar check-in&#10;        delete_response = self.client.delete(&#10;            reverse('workout-detail', kwargs={'pk': checkin_id})&#10;        )&#10;        self.assertEqual(delete_response.status_code, status.HTTP_204_NO_CONTENT)&#10;&#10;    def test_streak_calculation_through_api(self):&#10;        &quot;&quot;&quot;Testa cálculo de streak através da API&quot;&quot;&quot;&#10;        self.client.force_authenticate(user=self.user)&#10;&#10;        # Criar múltiplos check-ins para testar streak&#10;        for i in range(3):&#10;            data = {&#10;                'workout_date': timezone.now() - timedelta(days=i),&#10;                'duration': timedelta(minutes=60)&#10;            }&#10;            response = self.client.post(reverse('workout-list'), data)&#10;            self.assertEqual(response.status_code, status.HTTP_201_CREATED)&#10;&#10;        # Verificar streak no último check-in&#10;        last_checkin_response = self.client.get(reverse('workout-list'))&#10;        self.assertEqual(last_checkin_response.status_code, status.HTTP_200_OK)&#10;&#10;        # Pelo menos um check-in deve ter streak &gt; 0&#10;        has_streak = any(&#10;            item['current_streak'] &gt; 0&#10;            for item in last_checkin_response.data&#10;        )&#10;        self.assertTrue(has_streak)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>